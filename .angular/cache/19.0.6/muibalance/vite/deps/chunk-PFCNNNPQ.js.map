{
  "version": 3,
  "sources": ["../../../../../../node_modules/rxdb/dist/esm/rx-schema.js", "../../../../../../node_modules/rxdb/dist/esm/rx-change-event.js", "../../../../../../node_modules/rxdb/dist/esm/incremental-write.js", "../../../../../../node_modules/rxdb/dist/esm/rx-document.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/util.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/states/index.js", "../../../../../../node_modules/array-push-at-sort-position/dist/esm/index.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/actions/index.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/util.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js", "../../../../../../node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js", "../../../../../../node_modules/event-reduce-js/dist/esm/src/index.js", "../../../../../../node_modules/rxdb/dist/esm/event-reduce.js", "../../../../../../node_modules/rxdb/dist/esm/query-cache.js", "../../../../../../node_modules/rxdb/dist/esm/doc-cache.js", "../../../../../../node_modules/rxdb/dist/esm/rx-query-single-result.js", "../../../../../../node_modules/rxdb/dist/esm/rx-query.js", "../../../../../../node_modules/rxdb/dist/esm/rx-database-internal-store.js", "../../../../../../node_modules/rxdb/dist/esm/rx-collection-helper.js", "../../../../../../node_modules/rxdb/dist/esm/change-event-buffer.js", "../../../../../../node_modules/rxdb/dist/esm/rx-document-prototype-merge.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/default-conflict-handler.js", "../../../../../../node_modules/rxdb/dist/esm/rx-collection.js", "../../../../../../node_modules/custom-idle-queue/dist/es/index.js", "../../../../../../node_modules/rxdb/dist/esm/rx-database.js", "../../../../../../node_modules/rxdb/dist/esm/plugin.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/helper.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/downstream.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/conflicts.js", "../../../../../../node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js", "../../../../../../node_modules/rxdb/dist/esm/plugins/attachments/index.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/upstream.js", "../../../../../../node_modules/rxdb/dist/esm/replication-protocol/index.js", "../../../../../../node_modules/rxdb/dist/esm/custom-index.js"],
  "sourcesContent": ["import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { overwriteGetterForCaching, isMaybeReadonlyArray, deepEqual } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getFinalFields, getPrimaryFieldOfPrimaryKey, getSchemaByObjectPath, normalizeRxJsonSchema } from \"./rx-schema-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nexport var RxSchema = /*#__PURE__*/function () {\n  function RxSchema(jsonSchema, hashFunction) {\n    this.jsonSchema = jsonSchema;\n    this.hashFunction = hashFunction;\n    this.indexes = getIndexes(this.jsonSchema);\n\n    // primary is always required\n    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n\n    /**\n     * Many people accidentally put in wrong schema state\n     * without the dev-mode plugin, so we need this check here\n     * even in non-dev-mode.\n     */\n    if (!jsonSchema.properties[this.primaryPath].maxLength) {\n      throw newRxError('SC39', {\n        schema: jsonSchema\n      });\n    }\n    this.finalFields = getFinalFields(this.jsonSchema);\n  }\n  var _proto = RxSchema.prototype;\n  /**\n   * checks if a given change on a document is allowed\n   * Ensures that:\n   * - final fields are not modified\n   * @throws {Error} if not valid\n   */\n  _proto.validateChange = function validateChange(dataBefore, dataAfter) {\n    this.finalFields.forEach(fieldName => {\n      if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n        throw newRxError('DOC9', {\n          dataBefore,\n          dataAfter,\n          fieldName,\n          schema: this.jsonSchema\n        });\n      }\n    });\n  }\n\n  /**\n   * creates the schema-based document-prototype,\n   * see RxCollection.getDocumentPrototype()\n   */;\n  _proto.getDocumentPrototype = function getDocumentPrototype() {\n    var proto = {};\n\n    /**\n     * On the top level, we know all keys\n     * and therefore do not have to create a new Proxy object\n     * for each document. Instead we define the getter in the prototype once.\n     */\n    var pathProperties = getSchemaByObjectPath(this.jsonSchema, '');\n    Object.keys(pathProperties).forEach(key => {\n      var fullPath = key;\n\n      // getter - value\n      proto.__defineGetter__(key, function () {\n        if (!this.get || typeof this.get !== 'function') {\n          /**\n           * When an object gets added to the state of a vuejs-component,\n           * it happens that this getter is called with another scope.\n           * To prevent errors, we have to return undefined in this case\n           */\n          return undefined;\n        }\n        var ret = this.get(fullPath);\n        return ret;\n      });\n      // getter - observable$\n      Object.defineProperty(proto, key + '$', {\n        get: function () {\n          return this.get$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - reactivity$$\n      Object.defineProperty(proto, key + '$$', {\n        get: function () {\n          return this.get$$(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n      // getter - populate_\n      Object.defineProperty(proto, key + '_', {\n        get: function () {\n          return this.populate(fullPath);\n        },\n        enumerable: false,\n        configurable: false\n      });\n    });\n    overwriteGetterForCaching(this, 'getDocumentPrototype', () => proto);\n    return proto;\n  };\n  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {\n    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);\n  };\n  return _createClass(RxSchema, [{\n    key: \"version\",\n    get: function () {\n      return this.jsonSchema.version;\n    }\n  }, {\n    key: \"defaultValues\",\n    get: function () {\n      var values = {};\n      Object.entries(this.jsonSchema.properties).filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default')).forEach(([k, v]) => values[k] = v.default);\n      return overwriteGetterForCaching(this, 'defaultValues', values);\n    }\n\n    /**\n     * @overrides itself on the first call\n     */\n  }, {\n    key: \"hash\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'hash', this.hashFunction(JSON.stringify(this.jsonSchema)));\n    }\n  }]);\n}();\nexport function getIndexes(jsonSchema) {\n  return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema) {\n  var version = schema.version ? schema.version : 0;\n  var c = 0;\n  return new Array(version).fill(0).map(() => c++);\n}\nexport function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {\n  if (runPreCreateHooks) {\n    runPluginHooks('preCreateRxSchema', jsonSchema);\n  }\n  var useJsonSchema = fillWithDefaultSettings(jsonSchema);\n  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);\n  overwritable.deepFreezeWhenDevMode(useJsonSchema);\n  var schema = new RxSchema(useJsonSchema, hashFunction);\n  runPluginHooks('createRxSchema', schema);\n  return schema;\n}\nexport function isRxSchema(obj) {\n  return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema(schema) {\n  return schema;\n}\n", "/**\n * RxChangeEvents a emitted when something in the database changes\n * they can be grabbed by the observables of database, collection and document\n */\n\nimport { overwritable } from \"./overwritable.js\";\nimport { appendToArray, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nexport function getDocumentDataOfRxChangeEvent(rxChangeEvent) {\n  if (rxChangeEvent.documentData) {\n    return rxChangeEvent.documentData;\n  } else {\n    return rxChangeEvent.previousDocumentData;\n  }\n}\n\n/**\n * Might return null which means an\n * already deleted document got modified but still is deleted.\n * These kind of events are not relevant for the event-reduce algorithm\n * and must be filtered out.\n */\nexport function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {\n  switch (rxChangeEvent.operation) {\n    case 'INSERT':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: rxChangeEvent.documentData,\n        previous: null\n      };\n    case 'UPDATE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),\n        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : 'UNKNOWN'\n      };\n    case 'DELETE':\n      return {\n        operation: rxChangeEvent.operation,\n        id: rxChangeEvent.documentId,\n        doc: null,\n        previous: rxChangeEvent.previousDocumentData\n      };\n  }\n}\n\n/**\n * Flattens the given events into a single array of events.\n * Used mostly in tests.\n */\nexport function flattenEvents(input) {\n  var output = [];\n  if (Array.isArray(input)) {\n    input.forEach(inputItem => {\n      var add = flattenEvents(inputItem);\n      appendToArray(output, add);\n    });\n  } else {\n    if (input.id && input.events) {\n      // is bulk\n      input.events.forEach(ev => output.push(ev));\n    } else {\n      output.push(input);\n    }\n  }\n  var usedIds = new Set();\n  var nonDuplicate = [];\n  function getEventId(ev) {\n    return [ev.documentId, ev.documentData ? ev.documentData._rev : '', ev.previousDocumentData ? ev.previousDocumentData._rev : ''].join('|');\n  }\n  output.forEach(ev => {\n    var eventId = getEventId(ev);\n    if (!usedIds.has(eventId)) {\n      usedIds.add(eventId);\n      nonDuplicate.push(ev);\n    }\n  });\n  return nonDuplicate;\n}\nvar EVENT_BULK_CACHE = new Map();\nexport function rxChangeEventBulkToRxChangeEvents(eventBulk) {\n  return getFromMapOrCreate(EVENT_BULK_CACHE, eventBulk, () => {\n    var events = new Array(eventBulk.events.length);\n    var rawEvents = eventBulk.events;\n    var collectionName = eventBulk.collectionName;\n    var isLocal = eventBulk.isLocal;\n    var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n    for (var index = 0; index < rawEvents.length; index++) {\n      var event = rawEvents[index];\n      events[index] = {\n        documentId: event.documentId,\n        collectionName,\n        isLocal,\n        operation: event.operation,\n        documentData: deepFreezeWhenDevMode(event.documentData),\n        previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData)\n      };\n    }\n    return events;\n  });\n}\n", "import { isBulkWriteConflictError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate, getFromMapOrThrow, getHeightOfRevision, stripMetaDataFromDocument } from \"./plugins/utils/index.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse } from \"./rx-storage-helper.js\";\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport var IncrementalWriteQueue = /*#__PURE__*/function () {\n  function IncrementalWriteQueue(storageInstance, primaryPath,\n  // can be used to run hooks etc.\n  preWrite, postWrite) {\n    this.queueByDocId = new Map();\n    this.isRunning = false;\n    this.storageInstance = storageInstance;\n    this.primaryPath = primaryPath;\n    this.preWrite = preWrite;\n    this.postWrite = postWrite;\n  }\n  var _proto = IncrementalWriteQueue.prototype;\n  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {\n    var docId = lastKnownDocumentState[this.primaryPath];\n    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n    var ret = new Promise((resolve, reject) => {\n      var item = {\n        lastKnownDocumentState,\n        modifier,\n        resolve,\n        reject\n      };\n      ensureNotFalsy(ar).push(item);\n      this.triggerRun();\n    });\n    return ret;\n  };\n  _proto.triggerRun = async function triggerRun() {\n    if (this.isRunning === true || this.queueByDocId.size === 0) {\n      // already running\n      return;\n    }\n    this.isRunning = true;\n    var writeRows = [];\n\n    /**\n     * 'take over' so that while the async functions runs,\n     * new incremental updates could be added from the outside.\n     */\n    var itemsById = this.queueByDocId;\n    this.queueByDocId = new Map();\n    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {\n      var oldData = findNewestOfDocumentStates(items.map(i => i.lastKnownDocumentState));\n      var newData = oldData;\n      for (var item of items) {\n        try {\n          newData = await item.modifier(\n          /**\n           * We have to clone() each time because the modifier\n           * might throw while it already changed some properties\n           * of the document.\n           */\n          clone(newData));\n        } catch (err) {\n          item.reject(err);\n          item.reject = () => {};\n          item.resolve = () => {};\n        }\n      }\n      try {\n        await this.preWrite(newData, oldData);\n      } catch (err) {\n        /**\n         * If the before-hooks fail,\n         * we reject all of the writes because it is\n         * not possible to determine which one is to blame.\n         */\n        items.forEach(item => item.reject(err));\n        return;\n      }\n      writeRows.push({\n        previous: oldData,\n        document: newData\n      });\n    }));\n    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, 'incremental-write') : {\n      error: []\n    };\n\n    // process success\n    await Promise.all(getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map(result => {\n      var docId = result[this.primaryPath];\n      this.postWrite(result);\n      var items = getFromMapOrThrow(itemsById, docId);\n      items.forEach(item => item.resolve(result));\n    }));\n\n    // process errors\n    writeResult.error.forEach(error => {\n      var docId = error.documentId;\n      var items = getFromMapOrThrow(itemsById, docId);\n      var isConflict = isBulkWriteConflictError(error);\n      if (isConflict) {\n        // had conflict -> retry afterwards\n        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        /**\n         * Add the items back to this.queueByDocId\n         * by maintaining the original order.\n         */\n        items.reverse().forEach(item => {\n          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n          ensureNotFalsy(ar).unshift(item);\n        });\n      } else {\n        // other error -> must be thrown\n        var rxError = rxStorageWriteErrorToRxError(error);\n        items.forEach(item => item.reject(rxError));\n      }\n    });\n    this.isRunning = false;\n\n    /**\n     * Always trigger another run\n     * because in between there might be new items\n     * been added to the queue.\n     */\n    return this.triggerRun();\n  };\n  return IncrementalWriteQueue;\n}();\nexport function modifierFromPublicToInternal(publicModifier) {\n  var ret = async docData => {\n    var withoutMeta = stripMetaDataFromDocument(docData);\n    withoutMeta._deleted = docData._deleted;\n    var modified = await publicModifier(withoutMeta);\n    var reattachedMeta = Object.assign({}, modified, {\n      _meta: docData._meta,\n      _attachments: docData._attachments,\n      _rev: docData._rev,\n      _deleted: typeof modified._deleted !== 'undefined' ? modified._deleted : docData._deleted\n    });\n    if (typeof reattachedMeta._deleted === 'undefined') {\n      reattachedMeta._deleted = false;\n    }\n    return reattachedMeta;\n  };\n  return ret;\n}\nexport function findNewestOfDocumentStates(docs) {\n  var newest = docs[0];\n  var newestRevisionHeight = getHeightOfRevision(newest._rev);\n  docs.forEach(doc => {\n    var height = getHeightOfRevision(doc._rev);\n    if (height > newestRevisionHeight) {\n      newest = doc;\n      newestRevisionHeight = height;\n    }\n  });\n  return newest;\n}\n", "import { distinctUntilChanged, filter, map, shareReplay, startWith } from 'rxjs/operators';\nimport { clone, trimDots, pluginMissing, flatClone, PROMISE_RESOLVE_NULL, RXJS_SHARE_REPLAY_DEFAULTS, getProperty, getFromMapOrCreate, ensureNotFalsy } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { getDocumentDataOfRxChangeEvent } from \"./rx-change-event.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { modifierFromPublicToInternal } from \"./incremental-write.js\";\nexport var basePrototype = {\n  get primaryPath() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.collection.schema.primaryPath;\n  },\n  get primary() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data[_this.primaryPath];\n  },\n  get revision() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._rev;\n  },\n  get deleted$() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this.$.pipe(map(d => d._data._deleted));\n  },\n  get deleted$$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, _this.collection.database);\n  },\n  get deleted() {\n    var _this = this;\n    if (!_this.isInstanceOfRxDocument) {\n      return undefined;\n    }\n    return _this._data._deleted;\n  },\n  getLatest() {\n    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n    return this.collection._docCache.getCachedRxDocument(latestDocData);\n  },\n  /**\n   * returns the observable which emits the plain-data of this document\n   */\n  get $() {\n    var _this = this;\n    var id = this.primary;\n    return _this.collection.eventBulks$.pipe(filter(bulk => !bulk.isLocal), map(bulk => bulk.events.find(ev => ev.documentId === id)), filter(event => !!event), map(changeEvent => getDocumentDataOfRxChangeEvent(ensureNotFalsy(changeEvent))), startWith(_this.collection._docCache.getLatestDocumentData(id)), distinctUntilChanged((prev, curr) => prev._rev === curr._rev), map(docData => this.collection._docCache.getCachedRxDocument(docData)), shareReplay(RXJS_SHARE_REPLAY_DEFAULTS));\n  },\n  get $$() {\n    var _this = this;\n    var reactivity = _this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(_this.$, _this.getLatest()._data, _this.collection.database);\n  },\n  /**\n   * returns observable of the value of the given path\n   */\n  get$(path) {\n    if (overwritable.isDevMode()) {\n      if (path.includes('.item.')) {\n        throw newRxError('DOC1', {\n          path\n        });\n      }\n      if (path === this.primaryPath) {\n        throw newRxError('DOC2');\n      }\n\n      // final fields cannot be modified and so also not observed\n      if (this.collection.schema.finalFields.includes(path)) {\n        throw newRxError('DOC3', {\n          path\n        });\n      }\n      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n      if (!schemaObj) {\n        throw newRxError('DOC4', {\n          path\n        });\n      }\n    }\n    return this.$.pipe(map(data => getProperty(data, path)), distinctUntilChanged());\n  },\n  get$$(path) {\n    var obs = this.get$(path);\n    var reactivity = this.collection.database.getReactivityFactory();\n    return reactivity.fromObservable(obs, this.getLatest().get(path), this.collection.database);\n  },\n  /**\n   * populate the given path\n   */\n  populate(path) {\n    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);\n    var value = this.get(path);\n    if (!value) {\n      return PROMISE_RESOLVE_NULL;\n    }\n    if (!schemaObj) {\n      throw newRxError('DOC5', {\n        path\n      });\n    }\n    if (!schemaObj.ref) {\n      throw newRxError('DOC6', {\n        path,\n        schemaObj\n      });\n    }\n    var refCollection = this.collection.database.collections[schemaObj.ref];\n    if (!refCollection) {\n      throw newRxError('DOC7', {\n        ref: schemaObj.ref,\n        path,\n        schemaObj\n      });\n    }\n    if (schemaObj.type === 'array') {\n      return refCollection.findByIds(value).exec().then(res => {\n        var valuesIterator = res.values();\n        return Array.from(valuesIterator);\n      });\n    } else {\n      return refCollection.findOne(value).exec();\n    }\n  },\n  /**\n   * get data by objectPath\n   * @hotPath Performance here is really important,\n   * run some tests before changing anything.\n   */\n  get(objPath) {\n    return getDocumentProperty(this, objPath);\n  },\n  toJSON(withMetaFields = false) {\n    if (!withMetaFields) {\n      var data = flatClone(this._data);\n      delete data._rev;\n      delete data._attachments;\n      delete data._deleted;\n      delete data._meta;\n      return overwritable.deepFreezeWhenDevMode(data);\n    } else {\n      return overwritable.deepFreezeWhenDevMode(this._data);\n    }\n  },\n  toMutableJSON(withMetaFields = false) {\n    return clone(this.toJSON(withMetaFields));\n  },\n  /**\n   * updates document\n   * @overwritten by plugin (optional)\n   * @param updateObj mongodb-like syntax\n   */\n  update(_updateObj) {\n    throw pluginMissing('update');\n  },\n  incrementalUpdate(_updateObj) {\n    throw pluginMissing('update');\n  },\n  updateCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  },\n  putAttachment() {\n    throw pluginMissing('attachments');\n  },\n  getAttachment() {\n    throw pluginMissing('attachments');\n  },\n  allAttachments() {\n    throw pluginMissing('attachments');\n  },\n  get allAttachments$() {\n    throw pluginMissing('attachments');\n  },\n  async modify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    var oldData = this._data;\n    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * runs an incremental update over the document\n   * @param function that takes the document-data and returns a new data-object\n   */\n  incrementalModify(mutationFunction,\n  // used by some plugins that wrap the method\n  _context) {\n    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then(result => this.collection._docCache.getCachedRxDocument(result));\n  },\n  patch(patch) {\n    var oldData = this._data;\n    var newData = clone(oldData);\n    Object.entries(patch).forEach(([k, v]) => {\n      newData[k] = v;\n    });\n    return this._saveData(newData, oldData);\n  },\n  /**\n   * patches the given properties\n   */\n  incrementalPatch(patch) {\n    return this.incrementalModify(docData => {\n      Object.entries(patch).forEach(([k, v]) => {\n        docData[k] = v;\n      });\n      return docData;\n    });\n  },\n  /**\n   * saves the new document-data\n   * and handles the events\n   */\n  async _saveData(newData, oldData) {\n    newData = flatClone(newData);\n\n    // deleted documents cannot be changed\n    if (this._data._deleted) {\n      throw newRxError('DOC11', {\n        id: this.primary,\n        document: this\n      });\n    }\n    await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n    var writeRows = [{\n      previous: oldData,\n      document: newData\n    }];\n    var writeResult = await this.collection.storageInstance.bulkWrite(writeRows, 'rx-document-save-data');\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);\n    await this.collection._runHooks('post', 'save', newData, this);\n    return this.collection._docCache.getCachedRxDocument(getWrittenDocumentsFromBulkWriteResponse(this.collection.schema.primaryPath, writeRows, writeResult)[0]);\n  },\n  /**\n   * Remove the document.\n   * Notice that there is no hard delete,\n   * instead deleted documents get flagged with _deleted=true.\n   */\n  async remove() {\n    if (this.deleted) {\n      return Promise.reject(newRxError('DOC13', {\n        document: this,\n        id: this.primary\n      }));\n    }\n    var removeResult = await this.collection.bulkRemove([this]);\n    if (removeResult.error.length > 0) {\n      var error = removeResult.error[0];\n      throwIfIsStorageWriteError(this.collection, this.primary, this._data, error);\n    }\n    return removeResult.success[0];\n  },\n  incrementalRemove() {\n    return this.incrementalModify(async docData => {\n      await this.collection._runHooks('pre', 'remove', docData, this);\n      docData._deleted = true;\n      return docData;\n    }).then(async newDoc => {\n      await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n      return newDoc;\n    });\n  },\n  close() {\n    throw newRxError('DOC14');\n  }\n};\nexport function createRxDocumentConstructor(proto = basePrototype) {\n  var constructor = function RxDocumentConstructor(collection, docData) {\n    this.collection = collection;\n\n    // assume that this is always equal to the doc-data in the database\n    this._data = docData;\n    this._propertyCache = new Map();\n\n    /**\n     * because of the prototype-merge,\n     * we can not use the native instanceof operator\n     */\n    this.isInstanceOfRxDocument = true;\n  };\n  constructor.prototype = proto;\n  return constructor;\n}\nexport function createWithConstructor(constructor, collection, jsonData) {\n  var doc = new constructor(collection, jsonData);\n  runPluginHooks('createRxDocument', doc);\n  return doc;\n}\nexport function isRxDocument(obj) {\n  return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;\n}\nexport function beforeDocumentUpdateWrite(collection, newData, oldData) {\n  /**\n   * Meta values must always be merged\n   * instead of overwritten.\n   * This ensures that different plugins do not overwrite\n   * each others meta properties.\n   */\n  newData._meta = Object.assign({}, oldData._meta, newData._meta);\n\n  // ensure modifications are ok\n  if (overwritable.isDevMode()) {\n    collection.schema.validateChange(oldData, newData);\n  }\n  return collection._runHooks('pre', 'save', newData, oldData);\n}\nfunction getDocumentProperty(doc, objPath) {\n  return getFromMapOrCreate(doc._propertyCache, objPath, () => {\n    var valueObj = getProperty(doc._data, objPath);\n\n    // direct return if array or non-object\n    if (typeof valueObj !== 'object' || valueObj === null || Array.isArray(valueObj)) {\n      return overwritable.deepFreezeWhenDevMode(valueObj);\n    }\n    var proxy = new Proxy(\n    /**\n     * In dev-mode, the _data is deep-frozen\n     * so we have to flat clone here so that\n     * the proxy can work.\n     */\n    flatClone(valueObj), {\n      /**\n       * @performance is really important here\n       * because people access nested properties very often\n       * and might not be aware that this is internally using a Proxy\n       */\n      get(target, property) {\n        if (typeof property !== 'string') {\n          return target[property];\n        }\n        var lastChar = property.charAt(property.length - 1);\n        if (lastChar === '$') {\n          if (property.endsWith('$$')) {\n            var key = property.slice(0, -2);\n            return doc.get$$(trimDots(objPath + '.' + key));\n          } else {\n            var _key = property.slice(0, -1);\n            return doc.get$(trimDots(objPath + '.' + _key));\n          }\n        } else if (lastChar === '_') {\n          var _key2 = property.slice(0, -1);\n          return doc.populate(trimDots(objPath + '.' + _key2));\n        } else {\n          /**\n           * Performance shortcut\n           * In most cases access to nested properties\n           * will only access simple values which can be directly returned\n           * without creating a new Proxy or utilizing the cache.\n           */\n          var plainValue = target[property];\n          if (typeof plainValue === 'number' || typeof plainValue === 'string' || typeof plainValue === 'boolean') {\n            return plainValue;\n          }\n          return getDocumentProperty(doc, trimDots(objPath + '.' + property));\n        }\n      }\n    });\n    return proxy;\n  });\n}\n;\n", "export function lastOfArray(ar) {\n  return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/5915122\n */\nexport function randomOfArray(items) {\n  return items[Math.floor(Math.random() * items.length)];\n}\nexport function shuffleArray(arr) {\n  return arr.slice().sort(() => Math.random() - 0.5);\n}\n/**\n * normalizes sort-field\n * in: '-age'\n * out: 'age'\n */\nexport function normalizeSortField(field) {\n  if (field.startsWith('-')) {\n    return field.substr(1);\n  } else {\n    return field;\n  }\n}\nexport function getSortFieldsOfQuery(query) {\n  if (!query.sort) {\n    // if no sort-order is set, use the primary key\n    return ['_id'];\n  }\n  return query.sort.map(maybeArray => {\n    if (Array.isArray(maybeArray)) {\n      return maybeArray[0].map(field => normalizeSortField(field));\n    } else {\n      return normalizeSortField(maybeArray);\n    }\n  });\n}\n/**\n *  @link https://stackoverflow.com/a/1431113\n */\nexport function replaceCharAt(str, index, replacement) {\n  return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\nexport function mapToObject(map) {\n  const ret = {};\n  map.forEach((value, key) => {\n    ret[key] = value;\n  });\n  return ret;\n}\nexport function objectToMap(object) {\n  const ret = new Map();\n  Object.entries(object).forEach(([k, v]) => {\n    ret.set(k, v);\n  });\n  return ret;\n}\nexport function cloneMap(map) {\n  const ret = new Map();\n  map.forEach((value, key) => {\n    ret[key] = value;\n  });\n  return ret;\n}\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone(obj) {\n  return Object.assign({}, obj);\n}\nexport function ensureNotFalsy(obj) {\n  if (!obj) {\n    throw new Error('ensureNotFalsy() is falsy');\n  }\n  return obj;\n}\nexport function mergeSets(sets) {\n  let ret = new Set();\n  sets.forEach(set => {\n    ret = new Set([...ret, ...set]);\n  });\n  return ret;\n}\n/**\n * @link https://stackoverflow.com/a/12830454/3443137\n */\nexport function roundToTwoDecimals(num) {\n  return parseFloat(num.toFixed(2));\n}\nexport function isObject(value) {\n  const type = typeof value;\n  return value !== null && (type === 'object' || type === 'function');\n}\nexport function getProperty(object, path, value) {\n  if (Array.isArray(path)) {\n    path = path.join('.');\n  }\n  if (!isObject(object) || typeof path !== 'string') {\n    return value === undefined ? object : value;\n  }\n  const pathArray = path.split('.');\n  if (pathArray.length === 0) {\n    return value;\n  }\n  for (let index = 0; index < pathArray.length; index++) {\n    const key = pathArray[index];\n    if (isStringIndex(object, key)) {\n      object = index === pathArray.length - 1 ? undefined : null;\n    } else {\n      object = object[key];\n    }\n    if (object === undefined || object === null) {\n      // `object` is either `undefined` or `null` so we want to stop the loop, and\n      // if this is not the last bit of the path, and\n      // if it didn't return `undefined`\n      // it would return `null` if `object` is `null`\n      // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n      if (index !== pathArray.length - 1) {\n        return value;\n      }\n      break;\n    }\n  }\n  return object === undefined ? value : object;\n}\nfunction isStringIndex(object, key) {\n  if (typeof key !== 'number' && Array.isArray(object)) {\n    const index = Number.parseInt(key, 10);\n    return Number.isInteger(index) && object[index] === object[key];\n  }\n  return false;\n}\n", "import { getProperty, lastOfArray } from '../util.js';\nexport const hasLimit = input => {\n  return !!input.queryParams.limit;\n};\nexport const isFindOne = input => {\n  return input.queryParams.limit === 1;\n};\nexport const hasSkip = input => {\n  if (input.queryParams.skip && input.queryParams.skip > 0) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const isDelete = input => {\n  return input.changeEvent.operation === 'DELETE';\n};\nexport const isInsert = input => {\n  return input.changeEvent.operation === 'INSERT';\n};\nexport const isUpdate = input => {\n  return input.changeEvent.operation === 'UPDATE';\n};\nexport const wasLimitReached = input => {\n  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;\n};\nexport const sortParamsChanged = input => {\n  const sortFields = input.queryParams.sortFields;\n  const prev = input.changeEvent.previous;\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  if (!prev) {\n    return true;\n  }\n  for (let i = 0; i < sortFields.length; i++) {\n    const field = sortFields[i];\n    const beforeData = getProperty(prev, field);\n    const afterData = getProperty(doc, field);\n    if (beforeData !== afterData) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const wasInResult = input => {\n  const id = input.changeEvent.id;\n  if (input.keyDocumentMap) {\n    const has = input.keyDocumentMap.has(id);\n    return has;\n  } else {\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n      const item = results[i];\n      if (item[primary] === id) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\nexport const wasFirst = input => {\n  const first = input.previousResults[0];\n  if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasLast = input => {\n  const last = lastOfArray(input.previousResults);\n  if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  } else {\n    return false;\n  }\n};\nexport const wasSortedBeforeFirst = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  /**\n   * If the changed document is the same as the first,\n   * we cannot sort-compare them, because it might end in a non-deterministic\n   * sort order. Because both document could be equal.\n   * So instead we have to return true.\n   */\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, first);\n  return comp < 0;\n};\nexport const wasSortedAfterLast = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(prev, last);\n  return comp > 0;\n};\nexport const isSortedBeforeFirst = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const first = input.previousResults[0];\n  if (!first) {\n    return false;\n  }\n  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, first);\n  return comp < 0;\n};\nexport const isSortedAfterLast = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const last = lastOfArray(input.previousResults);\n  if (!last) {\n    return false;\n  }\n  if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n    return true;\n  }\n  const comp = input.queryParams.sortComparator(doc, last);\n  return comp > 0;\n};\nexport const wasMatching = input => {\n  const prev = input.changeEvent.previous;\n  if (!prev) {\n    return false;\n  }\n  return input.queryParams.queryMatcher(prev);\n};\nexport const doesMatchNow = input => {\n  const doc = input.changeEvent.doc;\n  if (!doc) {\n    return false;\n  }\n  const ret = input.queryParams.queryMatcher(doc);\n  return ret;\n};\nexport const wasResultsEmpty = input => {\n  return input.previousResults.length === 0;\n};\n", "import { hasLimit, isFindOne, hasSkip, wasResultsEmpty, isDelete, isInsert, isUpdate, wasLimitReached, sortParamsChanged, wasInResult, wasFirst, wasLast, wasSortedBeforeFirst, wasSortedAfterLast, isSortedBeforeFirst, isSortedAfterLast, wasMatching, doesMatchNow } from './state-resolver.js';\nexport * from './state-resolver.js';\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList = ['isInsert', 'isUpdate', 'isDelete', 'hasLimit', 'isFindOne', 'hasSkip', 'wasResultsEmpty', 'wasLimitReached', 'wasFirst', 'wasLast', 'sortParamsChanged', 'wasInResult', 'wasSortedBeforeFirst', 'wasSortedAfterLast', 'isSortedBeforeFirst', 'isSortedAfterLast', 'wasMatching', 'doesMatchNow'];\nexport const stateResolveFunctions = {\n  isInsert,\n  isUpdate,\n  isDelete,\n  hasLimit,\n  isFindOne,\n  hasSkip,\n  wasResultsEmpty,\n  wasLimitReached,\n  wasFirst,\n  wasLast,\n  sortParamsChanged,\n  wasInResult,\n  wasSortedBeforeFirst,\n  wasSortedAfterLast,\n  isSortedBeforeFirst,\n  isSortedAfterLast,\n  wasMatching,\n  doesMatchNow\n};\nexport const stateResolveFunctionByIndex = {\n  0: isInsert,\n  1: isUpdate,\n  2: isDelete,\n  3: hasLimit,\n  4: isFindOne,\n  5: hasSkip,\n  6: wasResultsEmpty,\n  7: wasLimitReached,\n  8: wasFirst,\n  9: wasLast,\n  10: sortParamsChanged,\n  11: wasInResult,\n  12: wasSortedBeforeFirst,\n  13: wasSortedAfterLast,\n  14: isSortedBeforeFirst,\n  15: isSortedAfterLast,\n  16: wasMatching,\n  17: doesMatchNow\n};\nexport function resolveState(stateName, input) {\n  const fn = stateResolveFunctions[stateName];\n  if (!fn) {\n    throw new Error('resolveState() has no function for ' + stateName);\n  }\n  return fn(input);\n}\nexport function getStateSet(input) {\n  let set = '';\n  for (let i = 0; i < orderedStateList.length; i++) {\n    const name = orderedStateList[i];\n    const value = resolveState(name, input);\n    const add = value ? '1' : '0';\n    set += add;\n  }\n  return set;\n}\nexport function logStateSet(stateSet) {\n  orderedStateList.forEach((state, index) => {\n    console.log('state: ' + state + ' : ' + stateSet[index]);\n  });\n}\n", "/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nexport function pushAtSortPosition(array, item, compareFunction, low) {\n  var length = array.length;\n  var high = length - 1;\n  var mid = 0;\n\n  /**\n   * Optimization shortcut.\n   */\n  if (length === 0) {\n    array.push(item);\n    return 0;\n  }\n\n  /**\n   * So we do not have to get the ret[mid] doc again\n   * at the last we store it here.\n   */\n  var lastMidDoc;\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = array[mid];\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n\n  /**\n   * Insert at correct position\n   */\n  array.splice(mid, 0, item);\n  return mid;\n}", "import { pushAtSortPosition } from 'array-push-at-sort-position';\nexport const doNothing = _input => {};\nexport const insertFirst = input => {\n  input.previousResults.unshift(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const insertLast = input => {\n  input.previousResults.push(input.changeEvent.doc);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);\n  }\n};\nexport const removeFirstItem = input => {\n  const first = input.previousResults.shift();\n  if (input.keyDocumentMap && first) {\n    input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);\n  }\n};\nexport const removeLastItem = input => {\n  const last = input.previousResults.pop();\n  if (input.keyDocumentMap && last) {\n    input.keyDocumentMap.delete(last[input.queryParams.primaryKey]);\n  }\n};\nexport const removeFirstInsertLast = input => {\n  removeFirstItem(input);\n  insertLast(input);\n};\nexport const removeLastInsertFirst = input => {\n  removeLastItem(input);\n  insertFirst(input);\n};\nexport const removeFirstInsertFirst = input => {\n  removeFirstItem(input);\n  insertFirst(input);\n};\nexport const removeLastInsertLast = input => {\n  removeLastItem(input);\n  insertLast(input);\n};\nexport const removeExisting = input => {\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.delete(input.changeEvent.id);\n  }\n  // find index of document\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // remove\n    if (item[primary] === input.changeEvent.id) {\n      results.splice(i, 1);\n      break;\n    }\n  }\n};\nexport const replaceExisting = input => {\n  // find index of document\n  const doc = input.changeEvent.doc;\n  const primary = input.queryParams.primaryKey;\n  const results = input.previousResults;\n  for (let i = 0; i < results.length; i++) {\n    const item = results[i];\n    // replace\n    if (item[primary] === input.changeEvent.id) {\n      results[i] = doc;\n      if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(input.changeEvent.id, doc);\n      }\n      break;\n    }\n  }\n};\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong = input => {\n  const wrongHuman = {\n    _id: 'wrongHuman' + new Date().getTime()\n  };\n  input.previousResults.length = 0; // clear array\n  input.previousResults.push(wrongHuman);\n  if (input.keyDocumentMap) {\n    input.keyDocumentMap.clear();\n    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);\n  }\n};\nexport const insertAtSortPosition = input => {\n  const docId = input.changeEvent.id;\n  const doc = input.changeEvent.doc;\n  if (input.keyDocumentMap) {\n    if (input.keyDocumentMap.has(docId)) {\n      /**\n       * If document is already in results,\n       * we cannot add it again because it would throw on non-deterministic ordering.\n       */\n      return;\n    }\n    input.keyDocumentMap.set(docId, doc);\n  } else {\n    const isDocInResults = input.previousResults.find(d => d[input.queryParams.primaryKey] === docId);\n    /**\n     * If document is already in results,\n     * we cannot add it again because it would throw on non-deterministic ordering.\n     */\n    if (isDocInResults) {\n      return;\n    }\n  }\n  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);\n};\nexport const removeExistingAndInsertAtSortPosition = input => {\n  removeExisting(input);\n  insertAtSortPosition(input);\n};\nexport const runFullQueryAgain = _input => {\n  throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\nexport const unknownAction = _input => {\n  throw new Error('Action unknownAction should never be called');\n};\n", "import { doNothing, insertFirst, insertLast, removeFirstItem, removeLastItem, removeFirstInsertLast, removeLastInsertFirst, removeExisting, replaceExisting, alwaysWrong, insertAtSortPosition, removeExistingAndInsertAtSortPosition, runFullQueryAgain, unknownAction, removeFirstInsertFirst, removeLastInsertLast } from './action-functions.js';\nexport * from './action-functions.js';\n/**\n * all actions ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedActionList = ['doNothing', 'insertFirst', 'insertLast', 'removeFirstItem', 'removeLastItem', 'removeFirstInsertLast', 'removeLastInsertFirst', 'removeFirstInsertFirst', 'removeLastInsertLast', 'removeExisting', 'replaceExisting', 'alwaysWrong', 'insertAtSortPosition', 'removeExistingAndInsertAtSortPosition', 'runFullQueryAgain', 'unknownAction'];\nexport const actionFunctions = {\n  doNothing,\n  insertFirst,\n  insertLast,\n  removeFirstItem,\n  removeLastItem,\n  removeFirstInsertLast,\n  removeLastInsertFirst,\n  removeFirstInsertFirst,\n  removeLastInsertLast,\n  removeExisting,\n  replaceExisting,\n  alwaysWrong,\n  insertAtSortPosition,\n  removeExistingAndInsertAtSortPosition,\n  runFullQueryAgain,\n  unknownAction\n};\n", "/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\nexport function getCharOfLevel(level) {\n  const charCode = CHAR_CODE_OFFSET + level;\n  return String.fromCharCode(charCode);\n}\nexport function getNumberOfChar(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode - CHAR_CODE_OFFSET;\n}\nexport function getCharOfValue(value) {\n  const charCode = CHAR_CODE_OFFSET + value;\n  return String.fromCharCode(charCode);\n}\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\nexport function getNextCharId(lastCode) {\n  // jump these codes because they look strange\n  if (lastCode >= 128 && lastCode <= 160) {\n    lastCode = 161;\n  }\n  const char = String.fromCharCode(lastCode);\n  return {\n    char,\n    nextCode: lastCode + 1\n  };\n}\n", "export function booleanStringToBoolean(str) {\n  if (str === '1') {\n    return true;\n  } else {\n    return false;\n  }\n}\nexport function booleanToBooleanString(b) {\n  if (b) {\n    return '1';\n  } else {\n    return '0';\n  }\n}\nexport function oppositeBoolean(input) {\n  if (input === '1') {\n    return '0';\n  } else {\n    return '1';\n  }\n}\nexport function lastChar(str) {\n  return str.slice(-1);\n}\n/**\n * @link https://stackoverflow.com/a/1349426\n */\nfunction makeid(length = 6) {\n  let result = '';\n  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\nconst nodeIdPrefix = makeid(4);\nlet lastIdGen = 0;\nexport function nextNodeId() {\n  const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;\n  lastIdGen++;\n  return ret;\n}\n/**\n * @link https://stackoverflow.com/a/16155417\n */\nexport function decimalToPaddedBinary(decimal, padding) {\n  const binary = (decimal >>> 0).toString(2);\n  const padded = binary.padStart(padding, '0');\n  return padded;\n}\nexport function oppositeBinary(i) {\n  if (i === '1') {\n    return '0';\n  } else if (i === '0') {\n    return '1';\n  } else {\n    throw new Error('non-binary given');\n  }\n}\nexport function binaryToDecimal(binary) {\n  return parseInt(binary, 2);\n}\nexport function minBinaryWithLength(length) {\n  return new Array(length).fill(0).map(() => '0').join('');\n}\nexport function maxBinaryWithLength(length) {\n  return new Array(length).fill(0).map(() => '1').join('');\n}\nexport function getNextStateSet(stateSet) {\n  const decimal = binaryToDecimal(stateSet);\n  const increase = decimal + 1;\n  const binary = decimalToPaddedBinary(increase, stateSet.length);\n  return binary;\n}\nexport function firstKeyOfMap(map) {\n  const iterator1 = map.keys();\n  return iterator1.next().value;\n}\n/**\n * Shuffles array in place. ES6 version\n * @link https://stackoverflow.com/a/6274381\n */\nexport function shuffleArray(a) {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\nexport function lastOfArray(ar) {\n  return ar[ar.length - 1];\n}\n/**\n * @link https://stackoverflow.com/a/6259536\n */\nexport function splitStringToChunks(str, chunkSize) {\n  const chunks = [];\n  for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {\n    chunks.push(str.substring(i, i + chunkSize));\n  }\n  return chunks;\n}\n", "import { splitStringToChunks } from '../util.js';\nimport { getNumberOfChar } from './string-format.js';\nexport function minimalStringToSimpleBdd(str) {\n  const nodesById = new Map();\n  // parse leaf nodes\n  const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);\n  const lastLeafNodeChar = 2 + leafNodeAmount * 2;\n  const leafNodeChars = str.substring(2, lastLeafNodeChar);\n  const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);\n  for (let i = 0; i < leafNodeChunks.length; i++) {\n    const chunk = leafNodeChunks[i];\n    const id = chunk.charAt(0);\n    const value = getNumberOfChar(chunk.charAt(1));\n    nodesById.set(id, value);\n  }\n  // parse internal nodes\n  const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);\n  const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);\n  for (let i = 0; i < internalNodeChunks.length; i++) {\n    const chunk = internalNodeChunks[i];\n    const id = chunk.charAt(0);\n    const idOf0Branch = chunk.charAt(1);\n    const idOf1Branch = chunk.charAt(2);\n    const level = getNumberOfChar(chunk.charAt(3));\n    if (!nodesById.has(idOf0Branch)) {\n      throw new Error('missing node with id ' + idOf0Branch);\n    }\n    if (!nodesById.has(idOf1Branch)) {\n      throw new Error('missing node with id ' + idOf1Branch);\n    }\n    const node0 = nodesById.get(idOf0Branch);\n    const node1 = nodesById.get(idOf1Branch);\n    const node = {\n      l: level,\n      // level is first for prettier json output\n      0: node0,\n      1: node1\n    };\n    nodesById.set(id, node);\n  }\n  // parse root node\n  const last3 = str.slice(-3);\n  const idOf0 = last3.charAt(0);\n  const idOf1 = last3.charAt(1);\n  const levelOfRoot = getNumberOfChar(last3.charAt(2));\n  const nodeOf0 = nodesById.get(idOf0);\n  const nodeOf1 = nodesById.get(idOf1);\n  const rootNode = {\n    l: levelOfRoot,\n    0: nodeOf0,\n    1: nodeOf1\n  };\n  return rootNode;\n}\n", "import { booleanToBooleanString } from '../util.js';\nexport function resolveWithSimpleBdd(simpleBdd, fns, input) {\n  let currentNode = simpleBdd;\n  let currentLevel = simpleBdd.l;\n  while (true) {\n    const booleanResult = fns[currentLevel](input);\n    const branchKey = booleanToBooleanString(booleanResult);\n    currentNode = currentNode[branchKey];\n    if (typeof currentNode === 'number' || typeof currentNode === 'string') {\n      return currentNode;\n    } else {\n      currentLevel = currentNode.l;\n    }\n  }\n}\n", "import { minimalStringToSimpleBdd, resolveWithSimpleBdd } from 'binary-decision-diagram';\nimport { stateResolveFunctionByIndex } from '../states/index.js';\nexport const minimalBddString = '14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9¡bf9¢bq9£cg9¤ck9¥cn9¦nd9§np9¨nq9©nf9ªng9«nm9¬nk9­mr9®ms9¯mt9°mj9±mk9²ml9³mn9´mc8µ³{8¶¯}8·°¤8¸³§8¹mn8º³«8»³m8¼m´4½z²4¾³w4¿zµ4À¯¶4Á°·4Â³º4Ã³¸4Äm¹4Åv¤7Æyn7ÇÀÁ7È~7É¥¤7ÊÃÄ7Ë¨n7Ìº¹7Í­°7Î®m7Ï¯°7Ð±m7Ñ³m7Ò¼m5ÓÄm5Ô¹m5Õ½°5Ö¾m5×¿°5ØÇÏ5ÙÂm5ÚÊÑ5Û±m5Üºm5ÝÌÑ5ÞÕÍ2ß|2à¡u2á£Å2âÖÎ2ã¦Æ2ä©x2åªÆ2æ×Ø2ç|È2è¡¢2é£É2ê¤¥2ëÙÚ2ì¦Ë2í©n2îªn2ïÛÐ2ðÜÝ2ñ¬n2òÒÓ/óan/ôbn/õcn/öÞâ/÷ßã/øàä/ùáå/úæë/ûçì/üèí/ýéî/þÍÎ/ÿÏÑ/ĀòÔ,ācn,Ăöï,ă¤ñ,Ąúð,ąêñ,ĆþÐ,ćÿÑ,Ĉac0ĉbc0Ċóõ0ċôā0Čßá0čà¤0Ďçé0ďèê0Đ÷ù0đøă0Ēûý0ēüą0ĔmÒ-ĕmĀ-ĖÞæ-ėČĎ-Ęčď-ęĂĄ-ĚĐĒ-ěđē-Ĝ²»-ĝÍÏ-ĞĆć-ğ²³-ĠĔĈ3ġĕĊ3ĢĖė3ģęĚ3ĤĢĝ(ĥĜğ(ĦģĞ(ħĠġ+Ĩĉċ+ĩĤĦ+ĪĘě+īħĨ1ĬĩĪ1ĭĬī*Įĥm*ĭĮ.';\nlet simpleBdd;\nexport function getSimpleBdd() {\n  if (!simpleBdd) {\n    simpleBdd = minimalStringToSimpleBdd(minimalBddString);\n  }\n  return simpleBdd;\n}\nexport const resolveInput = input => {\n  return resolveWithSimpleBdd(getSimpleBdd(), stateResolveFunctionByIndex, input);\n};\n", "import { getStateSet } from './states/index.js';\nimport { actionFunctions, orderedActionList } from './actions/index.js';\nimport { resolveInput } from './bdd/bdd.generated.js';\nexport * from './states/index.js';\nexport * from './util.js';\nexport * from './actions/index.js';\nexport function calculateActionFromMap(stateSetToActionMap, input) {\n  const stateSet = getStateSet(input);\n  const actionName = stateSetToActionMap.get(stateSet);\n  if (!actionName) {\n    return {\n      action: 'runFullQueryAgain',\n      stateSet\n    };\n  } else {\n    return {\n      action: actionName,\n      stateSet\n    };\n  }\n}\nexport function calculateActionName(input) {\n  const resolvedActionId = resolveInput(input);\n  return orderedActionList[resolvedActionId];\n}\nexport function calculateActionFunction(input) {\n  const actionName = calculateActionName(input);\n  return actionFunctions[actionName];\n}\n/**\n * for performance reasons,\n * @mutates the input\n * @returns the new results\n */\nexport function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {\n  const fn = actionFunctions[action];\n  fn({\n    queryParams,\n    changeEvent,\n    previousResults,\n    keyDocumentMap\n  });\n  return previousResults;\n}\n", "import { calculateActionName, runAction } from 'event-reduce-js';\nimport { rxChangeEventToEventReduceChangeEvent } from \"./rx-change-event.js\";\nimport { clone, ensureNotFalsy, getFromMapOrCreate } from \"./plugins/utils/index.js\";\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from \"./rx-query-helper.js\";\nexport function getSortFieldsOfQuery(primaryKey, query) {\n  if (!query.sort || query.sort.length === 0) {\n    return [primaryKey];\n  } else {\n    return query.sort.map(part => Object.keys(part)[0]);\n  }\n}\nexport var RXQUERY_QUERY_PARAMS_CACHE = new WeakMap();\nexport function getQueryParams(rxQuery) {\n  return getFromMapOrCreate(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {\n    var collection = rxQuery.collection;\n    var normalizedMangoQuery = normalizeMangoQuery(collection.storageInstance.schema, clone(rxQuery.mangoQuery));\n    var primaryKey = collection.schema.primaryPath;\n\n    /**\n     * Create a custom sort comparator\n     * that uses the hooks to ensure\n     * we send for example compressed documents to be sorted by compressed queries.\n     */\n    var sortComparator = getSortComparator(collection.schema.jsonSchema, normalizedMangoQuery);\n    var useSortComparator = (docA, docB) => {\n      var sortComparatorData = {\n        docA,\n        docB,\n        rxQuery\n      };\n      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n    };\n\n    /**\n     * Create a custom query matcher\n     * that uses the hooks to ensure\n     * we send for example compressed documents to match compressed queries.\n     */\n    var queryMatcher = getQueryMatcher(collection.schema.jsonSchema, normalizedMangoQuery);\n    var useQueryMatcher = doc => {\n      var queryMatcherData = {\n        doc,\n        rxQuery\n      };\n      return queryMatcher(queryMatcherData.doc);\n    };\n    var ret = {\n      primaryKey: rxQuery.collection.schema.primaryPath,\n      skip: normalizedMangoQuery.skip,\n      limit: normalizedMangoQuery.limit,\n      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),\n      sortComparator: useSortComparator,\n      queryMatcher: useQueryMatcher\n    };\n    return ret;\n  });\n}\nexport function calculateNewResults(rxQuery, rxChangeEvents) {\n  if (!rxQuery.collection.database.eventReduce) {\n    return {\n      runFullQueryAgain: true\n    };\n  }\n  var queryParams = getQueryParams(rxQuery);\n  var previousResults = ensureNotFalsy(rxQuery._result).docsData.slice(0);\n  var previousResultsMap = ensureNotFalsy(rxQuery._result).docsDataMap;\n  var changed = false;\n  var eventReduceEvents = [];\n  for (var index = 0; index < rxChangeEvents.length; index++) {\n    var cE = rxChangeEvents[index];\n    var eventReduceEvent = rxChangeEventToEventReduceChangeEvent(cE);\n    if (eventReduceEvent) {\n      eventReduceEvents.push(eventReduceEvent);\n    }\n  }\n  var foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n    var stateResolveFunctionInput = {\n      queryParams,\n      changeEvent: eventReduceEvent,\n      previousResults,\n      keyDocumentMap: previousResultsMap\n    };\n    var actionName = calculateActionName(stateResolveFunctionInput);\n    if (actionName === 'runFullQueryAgain') {\n      return true;\n    } else if (actionName !== 'doNothing') {\n      changed = true;\n      runAction(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);\n      return false;\n    }\n  });\n  if (foundNonOptimizeable) {\n    return {\n      runFullQueryAgain: true\n    };\n  } else {\n    return {\n      runFullQueryAgain: false,\n      changed,\n      newResults: previousResults\n    };\n  }\n}\n", "/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\n\nimport { getFromMapOrCreate, nextTick, now, requestIdlePromise } from \"./plugins/utils/index.js\";\nexport var QueryCache = /*#__PURE__*/function () {\n  function QueryCache() {\n    this._map = new Map();\n  }\n  var _proto = QueryCache.prototype;\n  /**\n   * check if an equal query is in the cache,\n   * if true, return the cached one,\n   * if false, save the given one and return it\n   */\n  _proto.getByQuery = function getByQuery(rxQuery) {\n    var stringRep = rxQuery.toString();\n    var ret = getFromMapOrCreate(this._map, stringRep, () => rxQuery);\n    return ret;\n  };\n  return QueryCache;\n}();\nexport function createQueryCache() {\n  return new QueryCache();\n}\nexport function uncacheRxQuery(queryCache, rxQuery) {\n  rxQuery.uncached = true;\n  var stringRep = rxQuery.toString();\n  queryCache._map.delete(stringRep);\n}\nexport function countRxQuerySubscribers(rxQuery) {\n  return rxQuery.refCount$.observers.length;\n}\nexport var DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {\n  if (queryCache._map.size < tryToKeepMax) {\n    return;\n  }\n  var minUnExecutedLifetime = now() - unExecutedLifetime;\n  var maybeUncache = [];\n  var queriesInCache = Array.from(queryCache._map.values());\n  for (var rxQuery of queriesInCache) {\n    // filter out queries with subscribers\n    if (countRxQuerySubscribers(rxQuery) > 0) {\n      continue;\n    }\n    // directly uncache queries that never executed and are older than unExecutedLifetime\n    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n      uncacheRxQuery(queryCache, rxQuery);\n      continue;\n    }\n    maybeUncache.push(rxQuery);\n  }\n  var mustUncache = maybeUncache.length - tryToKeepMax;\n  if (mustUncache <= 0) {\n    return;\n  }\n  var sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n  var toRemove = sortedByLastUsage.slice(0, mustUncache);\n  toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n};\nexport var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);\nexport var COLLECTIONS_WITH_RUNNING_CLEANUP = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(rxCollection) {\n  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n    // already started\n    return;\n  }\n  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n  /**\n   * Do not run directly to not reduce result latency of a new query\n   */\n  nextTick() // wait at least one tick\n  .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n  .then(() => {\n    if (!rxCollection.closed) {\n      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n    }\n    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n  });\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { getFromMapOrThrow, getHeightOfRevision, overwriteGetterForCaching, requestIdlePromiseNoQueue } from \"./plugins/utils/index.js\";\nimport { overwritable } from \"./overwritable.js\";\n\n/**\n * Because we have to create many cache items,\n * we use an array instead of an object with properties\n * for better performance and less memory usage.\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\n */\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport var DocumentCache = /*#__PURE__*/function () {\n  /**\n   * Process stuff lazy to not block the CPU\n   * on critical paths.\n   */\n\n  /**\n   * Some JavaScript runtimes like QuickJS,\n   * so not have a FinalizationRegistry or WeakRef.\n   * Therefore we need a workaround which might waste a lot of memory,\n   * but at least works.\n   */\n\n  function DocumentCache(primaryPath, changes$,\n  /**\n   * A method that can create a RxDocument by the given document data.\n   */\n  documentCreator) {\n    this.cacheItemByDocId = new Map();\n    this.tasks = new Set();\n    this.registry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(docMeta => {\n      var docId = docMeta.docId;\n      var cacheItem = this.cacheItemByDocId.get(docId);\n      if (cacheItem) {\n        cacheItem[0].delete(docMeta.revisionHeight);\n        if (cacheItem[0].size === 0) {\n          /**\n           * No state of the document is cached anymore,\n           * so we can clean up.\n           */\n          this.cacheItemByDocId.delete(docId);\n        }\n      }\n    }) : undefined;\n    this.primaryPath = primaryPath;\n    this.changes$ = changes$;\n    this.documentCreator = documentCreator;\n    changes$.subscribe(events => {\n      this.tasks.add(() => {\n        var cacheItemByDocId = this.cacheItemByDocId;\n        for (var index = 0; index < events.length; index++) {\n          var event = events[index];\n          var cacheItem = cacheItemByDocId.get(event.documentId);\n          if (cacheItem) {\n            var documentData = event.documentData;\n            if (!documentData) {\n              documentData = event.previousDocumentData;\n            }\n            cacheItem[1] = documentData;\n          }\n        }\n      });\n      if (this.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          this.processTasks();\n        });\n      }\n    });\n  }\n  var _proto = DocumentCache.prototype;\n  _proto.processTasks = function processTasks() {\n    if (this.tasks.size === 0) {\n      return;\n    }\n    var tasks = Array.from(this.tasks);\n    tasks.forEach(task => task());\n    this.tasks.clear();\n  }\n\n  /**\n   * Get the RxDocument from the cache\n   * and create a new one if not exits before.\n   * @overwrites itself with the actual function\n   * because this is @performance relevant.\n   * It is called on each document row for each write and read.\n   */;\n  /**\n   * Throws if not exists\n   */\n  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {\n    this.processTasks();\n    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n    return cacheItem[1];\n  };\n  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {\n    this.processTasks();\n    var cacheItem = this.cacheItemByDocId.get(docId);\n    if (cacheItem) {\n      return cacheItem[1];\n    }\n  };\n  return _createClass(DocumentCache, [{\n    key: \"getCachedRxDocuments\",\n    get: function () {\n      var fn = getCachedRxDocumentMonad(this);\n      return overwriteGetterForCaching(this, 'getCachedRxDocuments', fn);\n    }\n  }, {\n    key: \"getCachedRxDocument\",\n    get: function () {\n      var fn = getCachedRxDocumentMonad(this);\n      return overwriteGetterForCaching(this, 'getCachedRxDocument', doc => fn([doc])[0]);\n    }\n  }]);\n}();\n\n/**\n * This function is called very very often.\n * This is likely the most important function for RxDB overall performance\n * @hotPath This is one of the most important methods for performance.\n * It is used in many places to transform the raw document data into RxDocuments.\n */\nfunction getCachedRxDocumentMonad(docCache) {\n  var primaryPath = docCache.primaryPath;\n  var cacheItemByDocId = docCache.cacheItemByDocId;\n  var registry = docCache.registry;\n  var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n  var documentCreator = docCache.documentCreator;\n  var fn = docsData => {\n    var ret = new Array(docsData.length);\n    var registryTasks = [];\n    for (var index = 0; index < docsData.length; index++) {\n      var docData = docsData[index];\n      var docId = docData[primaryPath];\n      var revisionHeight = getHeightOfRevision(docData._rev);\n      var byRev = void 0;\n      var cachedRxDocumentWeakRef = void 0;\n      var cacheItem = cacheItemByDocId.get(docId);\n      if (!cacheItem) {\n        byRev = new Map();\n        cacheItem = [byRev, docData];\n        cacheItemByDocId.set(docId, cacheItem);\n      } else {\n        byRev = cacheItem[0];\n        cachedRxDocumentWeakRef = byRev.get(revisionHeight);\n      }\n      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n      if (!cachedRxDocument) {\n        docData = deepFreezeWhenDevMode(docData);\n        cachedRxDocument = documentCreator(docData);\n        byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));\n        if (registry) {\n          registryTasks.push(cachedRxDocument);\n        }\n      }\n      ret[index] = cachedRxDocument;\n    }\n    if (registryTasks.length > 0 && registry) {\n      /**\n       * Calling registry.register() has shown to have\n       * really bad performance. So we add the cached documents\n       * lazily.\n       */\n      docCache.tasks.add(() => {\n        for (var _index = 0; _index < registryTasks.length; _index++) {\n          var doc = registryTasks[_index];\n          registry.register(doc, {\n            docId: doc.primary,\n            revisionHeight: getHeightOfRevision(doc.revision)\n          });\n        }\n      });\n      if (docCache.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          docCache.processTasks();\n        });\n      }\n    }\n    return ret;\n  };\n  return fn;\n}\nexport function mapDocumentsDataToCacheDocs(docCache, docsData) {\n  var getCachedRxDocuments = docCache.getCachedRxDocuments;\n  return getCachedRxDocuments(docsData);\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nvar HAS_WEAK_REF = typeof WeakRef === 'function';\nvar createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\nfunction createWeakRef(obj) {\n  return new WeakRef(obj);\n}\nfunction createWeakRefFallback(obj) {\n  return {\n    deref() {\n      return obj;\n    }\n  };\n}\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { now, overwriteGetterForCaching } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\n/**\n * RxDB needs the query results in multiple formats.\n * Sometimes as a Map or an array with only the documentData.\n * For better performance we work with this class\n * that initializes stuff lazily so that\n * we can directly work with the query results after RxQuery.exec()\n */\nexport var RxQuerySingleResult = /*#__PURE__*/function () {\n  /**\n   * Time at which the current _result state was created.\n   * Used to determine if the result set has changed since X\n   * so that we do not emit the same result multiple times on subscription.\n   */\n\n  function RxQuerySingleResult(query,\n  // only used internally, do not use outside, use this.docsData instead\n  docsDataFromStorageInstance,\n  // can be overwritten for count-queries\n  count) {\n    this.time = now();\n    this.query = query;\n    this.count = count;\n    this.documents = mapDocumentsDataToCacheDocs(this.query.collection._docCache, docsDataFromStorageInstance);\n  }\n\n  /**\n   * Instead of using the newResultData in the result cache,\n   * we directly use the objects that are stored in the RxDocument\n   * to ensure we do not store the same data twice and fill up the memory.\n   * @overwrites itself with the actual value\n   */\n  var _proto = RxQuerySingleResult.prototype;\n  _proto.getValue = function getValue(throwIfMissing) {\n    var op = this.query.op;\n    if (op === 'count') {\n      return this.count;\n    } else if (op === 'findOne') {\n      // findOne()-queries emit RxDocument or null\n      var doc = this.documents.length === 0 ? null : this.documents[0];\n      if (!doc && throwIfMissing) {\n        throw newRxError('QU10', {\n          collection: this.query.collection.name,\n          query: this.query.mangoQuery,\n          op\n        });\n      } else {\n        return doc;\n      }\n    } else if (op === 'findByIds') {\n      return this.docsMap;\n    } else {\n      // find()-queries emit RxDocument[]\n      // Flat copy the array so it won't matter if the user modifies it.\n      return this.documents.slice(0);\n    }\n  };\n  return _createClass(RxQuerySingleResult, [{\n    key: \"docsData\",\n    get: function () {\n      return overwriteGetterForCaching(this, 'docsData', this.documents.map(d => d._data));\n    }\n\n    // A key->document map, used in the event reduce optimization.\n  }, {\n    key: \"docsDataMap\",\n    get: function () {\n      var map = new Map();\n      this.documents.forEach(d => {\n        map.set(d.primary, d._data);\n      });\n      return overwriteGetterForCaching(this, 'docsDataMap', map);\n    }\n  }, {\n    key: \"docsMap\",\n    get: function () {\n      var map = new Map();\n      var documents = this.documents;\n      for (var i = 0; i < documents.length; i++) {\n        var doc = documents[i];\n        map.set(doc.primary, doc);\n      }\n      return overwriteGetterForCaching(this, 'docsMap', map);\n    }\n  }]);\n}();\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { BehaviorSubject, merge } from 'rxjs';\nimport { mergeMap, filter, map, startWith, distinctUntilChanged, shareReplay } from 'rxjs/operators';\nimport { sortObject, pluginMissing, overwriteGetterForCaching, now, PROMISE_RESOLVE_FALSE, RXJS_SHARE_REPLAY_DEFAULTS, ensureNotFalsy, areRxDocumentArraysEqual, appendToArray } from \"./plugins/utils/index.js\";\nimport { newRxError, rxStorageWriteErrorToRxError } from \"./rx-error.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { calculateNewResults } from \"./event-reduce.js\";\nimport { triggerCacheReplacement } from \"./query-cache.js\";\nimport { getQueryMatcher, normalizeMangoQuery, prepareQuery, runQueryUpdateFunction } from \"./rx-query-helper.js\";\nimport { RxQuerySingleResult } from \"./rx-query-single-result.js\";\nvar _queryCount = 0;\nvar newQueryID = function () {\n  return ++_queryCount;\n};\nexport var RxQueryBase = /*#__PURE__*/function () {\n  /**\n   * Some stats then are used for debugging and cache replacement policies\n   */\n\n  // used in the query-cache to determine if the RxQuery can be cleaned up.\n\n  // used to count the subscribers to the query\n\n  /**\n   * Contains the current result state\n   * or null if query has not run yet.\n   */\n\n  function RxQueryBase(op, mangoQuery, collection,\n  // used by some plugins\n  other = {}) {\n    this.id = newQueryID();\n    this._execOverDatabaseCount = 0;\n    this._creationTime = now();\n    this._lastEnsureEqual = 0;\n    this.uncached = false;\n    this.refCount$ = new BehaviorSubject(null);\n    this._result = null;\n    this._latestChangeEvent = -1;\n    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;\n    this.op = op;\n    this.mangoQuery = mangoQuery;\n    this.collection = collection;\n    this.other = other;\n    if (!mangoQuery) {\n      this.mangoQuery = _getDefaultQuery();\n    }\n    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);\n  }\n  var _proto = RxQueryBase.prototype;\n  /**\n   * Returns an observable that emits the results\n   * This should behave like an rxjs-BehaviorSubject which means:\n   * - Emit the current result-set on subscribe\n   * - Emit the new result-set when an RxChangeEvent comes in\n   * - Do not emit anything before the first result-set was created (no null)\n   */\n  /**\n   * set the new result-data as result-docs of the query\n   * @param newResultData json-docs that were received from the storage\n   */\n  _proto._setResultData = function _setResultData(newResultData) {\n    if (typeof newResultData === 'undefined') {\n      throw newRxError('QU18', {\n        database: this.collection.database.name,\n        collection: this.collection.name\n      });\n    }\n    if (typeof newResultData === 'number') {\n      this._result = new RxQuerySingleResult(this, [], newResultData);\n      return;\n    } else if (newResultData instanceof Map) {\n      newResultData = Array.from(newResultData.values());\n    }\n    var newQueryResult = new RxQuerySingleResult(this, newResultData, newResultData.length);\n    this._result = newQueryResult;\n  }\n\n  /**\n   * executes the query on the database\n   * @return results-array with document-data\n   */;\n  _proto._execOverDatabase = async function _execOverDatabase() {\n    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n    if (this.op === 'count') {\n      var preparedQuery = this.getPreparedQuery();\n      var result = await this.collection.storageInstance.count(preparedQuery);\n      if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n        throw newRxError('QU14', {\n          collection: this.collection,\n          queryObj: this.mangoQuery\n        });\n      } else {\n        return result.count;\n      }\n    }\n    if (this.op === 'findByIds') {\n      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;\n      var ret = new Map();\n      var mustBeQueried = [];\n      // first try to fill from docCache\n      ids.forEach(id => {\n        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n        if (docData) {\n          if (!docData._deleted) {\n            var doc = this.collection._docCache.getCachedRxDocument(docData);\n            ret.set(id, doc);\n          }\n        } else {\n          mustBeQueried.push(id);\n        }\n      });\n      // everything which was not in docCache must be fetched from the storage\n      if (mustBeQueried.length > 0) {\n        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n        docs.forEach(docData => {\n          var doc = this.collection._docCache.getCachedRxDocument(docData);\n          ret.set(doc.primary, doc);\n        });\n      }\n      return ret;\n    }\n    var docsPromise = queryCollection(this);\n    return docsPromise.then(docs => {\n      return docs;\n    });\n  }\n\n  /**\n   * Execute the query\n   * To have an easier implementations,\n   * just subscribe and use the first result\n   */;\n  _proto.exec = async function exec(throwIfMissing) {\n    if (throwIfMissing && this.op !== 'findOne') {\n      throw newRxError('QU9', {\n        collection: this.collection.name,\n        query: this.mangoQuery,\n        op: this.op\n      });\n    }\n\n    /**\n     * run _ensureEqual() here,\n     * this will make sure that errors in the query which throw inside of the RxStorage,\n     * will be thrown at this execution context and not in the background.\n     */\n    await _ensureEqual(this);\n    var useResult = ensureNotFalsy(this._result);\n    return useResult.getValue(throwIfMissing);\n  }\n\n  /**\n   * cached call to get the queryMatcher\n   * @overwrites itself with the actual value\n   */;\n  /**\n   * returns a string that is used for equal-comparisons\n   * @overwrites itself with the actual value\n   */\n  _proto.toString = function toString() {\n    var stringObj = sortObject({\n      op: this.op,\n      query: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery),\n      other: this.other\n    }, true);\n    var value = JSON.stringify(stringObj);\n    this.toString = () => value;\n    return value;\n  }\n\n  /**\n   * returns the prepared query\n   * which can be send to the storage instance to query for documents.\n   * @overwrites itself with the actual value.\n   */;\n  _proto.getPreparedQuery = function getPreparedQuery() {\n    var hookInput = {\n      rxQuery: this,\n      // can be mutated by the hooks so we have to deep clone first.\n      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)\n    };\n    hookInput.mangoQuery.selector._deleted = {\n      $eq: false\n    };\n    if (hookInput.mangoQuery.index) {\n      hookInput.mangoQuery.index.unshift('_deleted');\n    }\n    runPluginHooks('prePrepareQuery', hookInput);\n    var value = prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);\n    this.getPreparedQuery = () => value;\n    return value;\n  }\n\n  /**\n   * returns true if the document matches the query,\n   * does not use the 'skip' and 'limit'\n   */;\n  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {\n    // if doc is deleted, it cannot match\n    if (docData._deleted) {\n      return false;\n    }\n    return this.queryMatcher(docData);\n  }\n\n  /**\n   * deletes all found documents\n   * @return promise with deleted documents\n   */;\n  _proto.remove = async function remove() {\n    var docs = await this.exec();\n    if (Array.isArray(docs)) {\n      var result = await this.collection.bulkRemove(docs);\n      if (result.error.length > 0) {\n        throw rxStorageWriteErrorToRxError(result.error[0]);\n      } else {\n        return result.success;\n      }\n    } else {\n      return docs.remove();\n    }\n  };\n  _proto.incrementalRemove = function incrementalRemove() {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalRemove());\n  }\n\n  /**\n   * helper function to transform RxQueryBase to RxQuery type\n   */;\n  /**\n   * updates all found documents\n   * @overwritten by plugin (optional)\n   */\n  _proto.update = function update(_updateObj) {\n    throw pluginMissing('update');\n  };\n  _proto.patch = function patch(_patch) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.patch(_patch));\n  };\n  _proto.incrementalPatch = function incrementalPatch(patch) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalPatch(patch));\n  };\n  _proto.modify = function modify(mutationFunction) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.modify(mutationFunction));\n  };\n  _proto.incrementalModify = function incrementalModify(mutationFunction) {\n    return runQueryUpdateFunction(this.asRxQuery, doc => doc.incrementalModify(mutationFunction));\n  }\n\n  // we only set some methods of query-builder here\n  // because the others depend on these ones\n  ;\n  _proto.where = function where(_queryObj) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.sort = function sort(_params) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.skip = function skip(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  _proto.limit = function limit(_amount) {\n    throw pluginMissing('query-builder');\n  };\n  return _createClass(RxQueryBase, [{\n    key: \"$\",\n    get: function () {\n      if (!this._$) {\n        var results$ = this.collection.eventBulks$.pipe(\n        /**\n         * Performance shortcut.\n         * Changes to local documents are not relevant for the query.\n         */\n        filter(bulk => !bulk.isLocal),\n        /**\n         * Start once to ensure the querying also starts\n         * when there where no changes.\n         */\n        startWith(null),\n        // ensure query results are up to date.\n        mergeMap(() => _ensureEqual(this)),\n        // use the current result set, written by _ensureEqual().\n        map(() => this._result),\n        // do not run stuff above for each new subscriber, only once.\n        shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n        // do not proceed if result set has not changed.\n        distinctUntilChanged((prev, curr) => {\n          if (prev && prev.time === ensureNotFalsy(curr).time) {\n            return true;\n          } else {\n            return false;\n          }\n        }), filter(result => !!result),\n        /**\n         * Map the result set to a single RxDocument or an array,\n         * depending on query type\n         */\n        map(result => {\n          return ensureNotFalsy(result).getValue();\n        }));\n        this._$ = merge(results$,\n        /**\n         * Also add the refCount$ to the query observable\n         * to allow us to count the amount of subscribers.\n         */\n        this.refCount$.pipe(filter(() => false)));\n      }\n      return this._$;\n    }\n  }, {\n    key: \"$$\",\n    get: function () {\n      var reactivity = this.collection.database.getReactivityFactory();\n      return reactivity.fromObservable(this.$, undefined, this.collection.database);\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n  }, {\n    key: \"queryMatcher\",\n    get: function () {\n      var schema = this.collection.schema.jsonSchema;\n      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);\n      return overwriteGetterForCaching(this, 'queryMatcher', getQueryMatcher(schema, normalizedQuery));\n    }\n  }, {\n    key: \"asRxQuery\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\nexport function _getDefaultQuery() {\n  return {\n    selector: {}\n  };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache(rxQuery) {\n  return rxQuery.collection._queryCache.getByQuery(rxQuery);\n}\nexport function createRxQuery(op, queryObj, collection, other) {\n  runPluginHooks('preCreateRxQuery', {\n    op,\n    queryObj,\n    collection,\n    other\n  });\n  var ret = new RxQueryBase(op, queryObj, collection, other);\n\n  // ensure when created with same params, only one is created\n  ret = tunnelQueryCache(ret);\n  triggerCacheReplacement(collection);\n  return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery) {\n  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nasync function _ensureEqual(rxQuery) {\n  if (rxQuery.collection.awaitBeforeReads.size > 0) {\n    await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\n  }\n\n  // Optimisation shortcut\n  if (rxQuery.collection.database.closed || _isResultsInSync(rxQuery)) {\n    return false;\n  }\n  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));\n  return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual(rxQuery) {\n  rxQuery._lastEnsureEqual = now();\n\n  /**\n   * Optimisation shortcuts\n   */\n  if (\n  // db is closed\n  rxQuery.collection.database.closed ||\n  // nothing happened since last run\n  _isResultsInSync(rxQuery)) {\n    return PROMISE_RESOLVE_FALSE;\n  }\n  var ret = false;\n  var mustReExec = false; // if this becomes true, a whole execution over the database is made\n  if (rxQuery._latestChangeEvent === -1) {\n    // have not executed yet -> must run\n    mustReExec = true;\n  }\n\n  /**\n   * try to use EventReduce to calculate the new results\n   */\n  if (!mustReExec) {\n    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n    if (missedChangeEvents === null) {\n      // changeEventBuffer is of bounds -> we must re-execute over the database\n      mustReExec = true;\n    } else {\n      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);\n      if (rxQuery.op === 'count') {\n        // 'count' query\n        var previousCount = ensureNotFalsy(rxQuery._result).count;\n        var newCount = previousCount;\n        runChangeEvents.forEach(cE => {\n          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n          var doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n          if (!didMatchBefore && doesMatchNow) {\n            newCount++;\n          }\n          if (didMatchBefore && !doesMatchNow) {\n            newCount--;\n          }\n        });\n        if (newCount !== previousCount) {\n          ret = true; // true because results changed\n          rxQuery._setResultData(newCount);\n        }\n      } else {\n        // 'find' or 'findOne' query\n        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);\n        if (eventReduceResult.runFullQueryAgain) {\n          // could not calculate the new results, execute must be done\n          mustReExec = true;\n        } else if (eventReduceResult.changed) {\n          // we got the new results, we do not have to re-execute, mustReExec stays false\n          ret = true; // true because results changed\n          rxQuery._setResultData(eventReduceResult.newResults);\n        }\n      }\n    }\n  }\n\n  // oh no we have to re-execute the whole query over the database\n  if (mustReExec) {\n    return rxQuery._execOverDatabase().then(newResultData => {\n      /**\n       * The RxStorage is defined to always first emit events and then return\n       * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n       * has been run, not the one from before.\n       */\n      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\n\n      // A count query needs a different has-changed check.\n      if (typeof newResultData === 'number') {\n        if (!rxQuery._result || newResultData !== rxQuery._result.count) {\n          ret = true;\n          rxQuery._setResultData(newResultData);\n        }\n        return ret;\n      }\n      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {\n        ret = true; // true because results changed\n        rxQuery._setResultData(newResultData);\n      }\n      return ret;\n    });\n  }\n  return Promise.resolve(ret); // true if results have changed\n}\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection(rxQuery) {\n  var docs = [];\n  var collection = rxQuery.collection;\n\n  /**\n   * Optimizations shortcut.\n   * If query is find-one-document-by-id,\n   * then we do not have to use the slow query() method\n   * but instead can use findDocumentsById()\n   */\n  if (rxQuery.isFindOneByIdQuery) {\n    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n      var docIds = rxQuery.isFindOneByIdQuery;\n      docIds = docIds.filter(docId => {\n        // first try to fill from docCache\n        var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n        if (docData) {\n          if (!docData._deleted) {\n            docs.push(docData);\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n      // otherwise get from storage\n      if (docIds.length > 0) {\n        var docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n        appendToArray(docs, docsFromStorage);\n      }\n    } else {\n      var docId = rxQuery.isFindOneByIdQuery;\n\n      // first try to fill from docCache\n      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n      if (!docData) {\n        // otherwise get from storage\n        var fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n        if (fromStorageList[0]) {\n          docData = fromStorageList[0];\n        }\n      }\n      if (docData && !docData._deleted) {\n        docs.push(docData);\n      }\n    }\n  } else {\n    var preparedQuery = rxQuery.getPreparedQuery();\n    var queryResult = await collection.storageInstance.query(preparedQuery);\n    docs = queryResult.documents;\n  }\n  return docs;\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(primaryPath, query) {\n  // must have exactly one operator which must be $eq || $in\n  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {\n    var value = query.selector[primaryPath];\n    if (typeof value === 'string') {\n      return value;\n    } else if (Object.keys(value).length === 1 && typeof value.$eq === 'string') {\n      return value.$eq;\n    }\n\n    // same with $in string arrays\n    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) &&\n    // must only contain strings\n    !value.$eq.find(r => typeof r !== 'string')) {\n      return value.$eq;\n    }\n  }\n  return false;\n}\nexport function isRxQuery(obj) {\n  return obj instanceof RxQueryBase;\n}\n", "import { isBulkWriteConflictError, newRxError } from \"./rx-error.js\";\nimport { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData } from \"./rx-schema-helper.js\";\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from \"./rx-storage-helper.js\";\nimport { clone, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, randomToken } from \"./plugins/utils/index.js\";\nimport { prepareQuery } from \"./rx-query-helper.js\";\nexport var INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport var INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport var INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\nexport var INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport var INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\nexport var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({\n  version: 0,\n  title: INTERNAL_STORE_SCHEMA_TITLE,\n  primaryKey: {\n    key: 'id',\n    fields: ['context', 'key'],\n    separator: '|'\n  },\n  type: 'object',\n  properties: {\n    id: {\n      type: 'string',\n      maxLength: 200\n    },\n    key: {\n      type: 'string'\n    },\n    context: {\n      type: 'string',\n      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, INTERNAL_CONTEXT_PIPELINE_CHECKPOINT, 'OTHER']\n    },\n    data: {\n      type: 'object',\n      additionalProperties: true\n    }\n  },\n  indexes: [],\n  required: ['key', 'context', 'data'],\n  additionalProperties: false,\n  /**\n   * If the sharding plugin is used,\n   * it must not shard on the internal RxStorageInstance\n   * because that one anyway has only a small amount of documents\n   * and also its creation is in the hot path of the initial page load,\n   * so we should spend less time creating multiple RxStorageInstances.\n   */\n  sharding: {\n    shards: 1,\n    mode: 'collection'\n  }\n});\nexport function getPrimaryKeyOfInternalDocument(key, context) {\n  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {\n    key,\n    context\n  });\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(storageInstance) {\n  var getAllQueryPrepared = prepareQuery(storageInstance.schema, {\n    selector: {\n      context: INTERNAL_CONTEXT_COLLECTION,\n      _deleted: {\n        $eq: false\n      }\n    },\n    sort: [{\n      id: 'asc'\n    }],\n    skip: 0\n  });\n  var queryResult = await storageInstance.query(getAllQueryPrepared);\n  var allDocs = queryResult.documents;\n  return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport var STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\nexport var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);\nexport async function ensureStorageTokenDocumentExists(rxDatabase) {\n  /**\n   * To have less read-write cycles,\n   * we just try to insert a new document\n   * and only fetch the existing one if a conflict happened.\n   */\n  var storageToken = randomToken(10);\n  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : undefined;\n  var docData = {\n    id: STORAGE_TOKEN_DOCUMENT_ID,\n    context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n    key: STORAGE_TOKEN_DOCUMENT_KEY,\n    data: {\n      rxdbVersion: rxDatabase.rxdbVersion,\n      token: storageToken,\n      /**\n       * We add the instance token here\n       * to be able to detect if a given RxDatabase instance\n       * is the first instance that was ever created\n       * or if databases have existed earlier on that storage\n       * with the same database name.\n       */\n      instanceToken: rxDatabase.token,\n      passwordHash\n    },\n    _deleted: false,\n    _meta: getDefaultRxDocumentMeta(),\n    _rev: getDefaultRevision(),\n    _attachments: {}\n  };\n  var writeRows = [{\n    document: docData\n  }];\n  var writeResult = await rxDatabase.internalStore.bulkWrite(writeRows, 'internal-add-storage-token');\n  if (!writeResult.error[0]) {\n    return getWrittenDocumentsFromBulkWriteResponse('id', writeRows, writeResult)[0];\n  }\n\n  /**\n   * If we get a 409 error,\n   * it means another instance already inserted the storage token.\n   * So we get that token from the database and return that one.\n   */\n  var error = ensureNotFalsy(writeResult.error[0]);\n  if (error.isError && isBulkWriteConflictError(error)) {\n    var conflictError = error;\n    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {\n      throw newRxError('DM5', {\n        args: {\n          database: rxDatabase.name,\n          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\n          codeVersion: rxDatabase.rxdbVersion\n        }\n      });\n    }\n    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {\n      throw newRxError('DB1', {\n        passwordHash,\n        existingPasswordHash: conflictError.documentInDb.data.passwordHash\n      });\n    }\n    var storageTokenDocInDb = conflictError.documentInDb;\n    return ensureNotFalsy(storageTokenDocInDb);\n  }\n  throw error;\n}\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {\n  if (!databaseStateVersion) {\n    return false;\n  }\n  var stateMajor = databaseStateVersion.split('.')[0];\n  var codeMajor = codeVersion.split('.')[0];\n\n  /**\n   * Version v15 data must be upwards compatible to v16\n   */\n  if (stateMajor === '15' && codeMajor === '16') {\n    return true;\n  }\n  if (stateMajor !== codeMajor) {\n    return false;\n  }\n  return true;\n}\nexport async function addConnectedStorageToCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if already in array\n    var alreadyThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (alreadyThere) {\n      return;\n    }\n\n    // otherwise add to array and save\n    saveData.data.connectedStorages.push({\n      collectionName: storageCollectionName,\n      schema\n    });\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'add-connected-storage-to-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\nexport async function removeConnectedStorageFromCollection(collection, storageCollectionName, schema) {\n  if (collection.schema.version !== schema.version) {\n    throw newRxError('SNH', {\n      schema,\n      version: collection.schema.version,\n      name: collection.name,\n      collection,\n      args: {\n        storageCollectionName\n      }\n    });\n  }\n  var collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n  var collectionDocId = getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION);\n  while (true) {\n    var collectionDoc = await getSingleDocument(collection.database.internalStore, collectionDocId);\n    var saveData = clone(ensureNotFalsy(collectionDoc));\n\n    // do nothing if not there\n    var isThere = saveData.data.connectedStorages.find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n    if (!isThere) {\n      return;\n    }\n\n    // otherwise remove from array and save\n    saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\n    try {\n      await writeSingle(collection.database.internalStore, {\n        previous: ensureNotFalsy(collectionDoc),\n        document: saveData\n      }, 'remove-connected-storage-from-collection');\n    } catch (err) {\n      if (!isBulkWriteConflictError(err)) {\n        throw err;\n      }\n      // retry on conflict\n    }\n  }\n}\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name, schema) {\n  return name + '-' + schema.version;\n}\n", "import { createRevision, flatClone, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"./plugins/utils/index.js\";\nimport { fillObjectWithDefaults, fillPrimaryKey } from \"./rx-schema-helper.js\";\nimport { runAsyncPluginHooks } from \"./hooks.js\";\nimport { getAllCollectionDocuments } from \"./rx-database-internal-store.js\";\nimport { flatCloneDocWithMeta } from \"./rx-storage-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { newRxError } from \"./rx-error.js\";\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert(schema, data) {\n  data = flatClone(data);\n  data = fillObjectWithDefaults(schema, data);\n  if (typeof schema.jsonSchema.primaryKey !== 'string') {\n    data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);\n  }\n  data._meta = getDefaultRxDocumentMeta();\n  if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {\n    data._deleted = false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {\n    data._attachments = {};\n  }\n  if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {\n    data._rev = getDefaultRevision();\n  }\n  return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {\n  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);\n  return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nexport async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, multiInstance, password,\n/**\n * If no hash function is provided,\n * we assume that the whole internal store is removed anyway\n * so we do not have to delete the meta documents.\n */\nhashFunction) {\n  var allCollectionMetaDocs = await getAllCollectionDocuments(databaseInternalStorage);\n  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter(metaDoc => metaDoc.data.name === collectionName);\n  var removeStorages = [];\n  relevantCollectionMetaDocs.forEach(metaDoc => {\n    removeStorages.push({\n      collectionName: metaDoc.data.name,\n      schema: metaDoc.data.schema,\n      isCollection: true\n    });\n    metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n      collectionName: row.collectionName,\n      isCollection: false,\n      schema: row.schema\n    }));\n  });\n\n  // ensure uniqueness\n  var alreadyAdded = new Set();\n  removeStorages = removeStorages.filter(row => {\n    var key = row.collectionName + '||' + row.schema.version;\n    if (alreadyAdded.has(key)) {\n      return false;\n    } else {\n      alreadyAdded.add(key);\n      return true;\n    }\n  });\n\n  // remove all the storages\n  await Promise.all(removeStorages.map(async row => {\n    var storageInstance = await storage.createStorageInstance({\n      collectionName: row.collectionName,\n      databaseInstanceToken,\n      databaseName,\n      /**\n       * multiInstance must be set to true if multiInstance\n       * was true on the database\n       * so that the storageInstance can inform other\n       * instances about being removed.\n       */\n      multiInstance,\n      options: {},\n      schema: row.schema,\n      password,\n      devMode: overwritable.isDevMode()\n    });\n    await storageInstance.remove();\n    if (row.isCollection) {\n      await runAsyncPluginHooks('postRemoveRxCollection', {\n        storage,\n        databaseName: databaseName,\n        collectionName\n      });\n    }\n  }));\n\n  // remove the meta documents\n  if (hashFunction) {\n    var writeRows = relevantCollectionMetaDocs.map(doc => {\n      var writeDoc = flatCloneDocWithMeta(doc);\n      writeDoc._deleted = true;\n      writeDoc._meta.lwt = now();\n      writeDoc._rev = createRevision(databaseInstanceToken, doc);\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    await databaseInternalStorage.bulkWrite(writeRows, 'rx-database-remove-collection-all');\n  }\n}\nexport function ensureRxCollectionIsNotClosed(collection) {\n  if (collection.closed) {\n    throw newRxError('COL21', {\n      collection: collection.name,\n      version: collection.schema.version\n    });\n  }\n}\n", "/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\n\nimport { filter } from 'rxjs/operators';\nimport { appendToArray, requestIdlePromiseNoQueue } from \"./plugins/utils/index.js\";\n\n/**\n * This buffer rembemers previous change events\n * so that queries can use them on .exec()\n * to calculate the new result set via event-reduce instead\n * of running the query against the storage.\n */\nexport var ChangeEventBuffer = /*#__PURE__*/function () {\n  /**\n   * These properties are private to ensure they cannot\n   * be read without first processing the lazy tasks.\n   */\n\n  /**\n   * array with changeEvents\n   * starts with oldest known event, ends with newest\n  */\n\n  function ChangeEventBuffer(collection) {\n    this.subs = [];\n    this.counter = 0;\n    this.eventCounterMap = new WeakMap();\n    this.buffer = [];\n    this.limit = 100;\n    this.tasks = new Set();\n    this.collection = collection;\n    this.subs.push(this.collection.eventBulks$.pipe(filter(bulk => !bulk.isLocal)).subscribe(eventBulk => {\n      this.tasks.add(() => this._handleChangeEvents(eventBulk.events));\n      if (this.tasks.size <= 1) {\n        requestIdlePromiseNoQueue().then(() => {\n          this.processTasks();\n        });\n      }\n    }));\n  }\n  var _proto = ChangeEventBuffer.prototype;\n  _proto.processTasks = function processTasks() {\n    if (this.tasks.size === 0) {\n      return;\n    }\n    var tasks = Array.from(this.tasks);\n    tasks.forEach(task => task());\n    this.tasks.clear();\n  };\n  _proto._handleChangeEvents = function _handleChangeEvents(events) {\n    var counterBefore = this.counter;\n    this.counter = this.counter + events.length;\n    if (events.length > this.limit) {\n      this.buffer = events.slice(events.length * -1);\n    } else {\n      appendToArray(this.buffer, events);\n      this.buffer = this.buffer.slice(this.limit * -1);\n    }\n    var counterBase = counterBefore + 1;\n    var eventCounterMap = this.eventCounterMap;\n    for (var index = 0; index < events.length; index++) {\n      var event = events[index];\n      eventCounterMap.set(event, counterBase + index);\n    }\n  };\n  _proto.getCounter = function getCounter() {\n    this.processTasks();\n    return this.counter;\n  };\n  _proto.getBuffer = function getBuffer() {\n    this.processTasks();\n    return this.buffer;\n  }\n\n  /**\n   * gets the array-index for the given pointer\n   * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n   */;\n  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {\n    this.processTasks();\n    var oldestEvent = this.buffer[0];\n    var oldestCounter = this.eventCounterMap.get(oldestEvent);\n    if (pointer < oldestCounter) return null; // out of bounds\n\n    var rest = pointer - oldestCounter;\n    return rest;\n  }\n\n  /**\n   * get all changeEvents which came in later than the pointer-event\n   * @return array with change-events. If null, pointer out of bounds\n   */;\n  _proto.getFrom = function getFrom(pointer) {\n    this.processTasks();\n    var ret = [];\n    var currentIndex = this.getArrayIndexByPointer(pointer);\n    if (currentIndex === null)\n      // out of bounds\n      return null;\n    while (true) {\n      var nextEvent = this.buffer[currentIndex];\n      currentIndex++;\n      if (!nextEvent) {\n        return ret;\n      } else {\n        ret.push(nextEvent);\n      }\n    }\n  };\n  _proto.runFrom = function runFrom(pointer, fn) {\n    this.processTasks();\n    var ret = this.getFrom(pointer);\n    if (ret === null) {\n      throw new Error('out of bounds');\n    } else {\n      ret.forEach(cE => fn(cE));\n    }\n  }\n\n  /**\n   * no matter how many operations are done on one document,\n   * only the last operation has to be checked to calculate the new state\n   * this function reduces the events to the last ChangeEvent of each doc.\n   * This functionality is currently disabled. It is questionable if\n   * pre-merging the events would really be faster or actually slower.\n   */;\n  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {\n    this.processTasks();\n    return changeEvents.slice(0);\n  };\n  _proto.close = function close() {\n    this.tasks.clear();\n    this.subs.forEach(sub => sub.unsubscribe());\n  };\n  return ChangeEventBuffer;\n}();\nexport function createChangeEventBuffer(collection) {\n  return new ChangeEventBuffer(collection);\n}\n", "/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\nimport { createRxDocumentConstructor, basePrototype, createWithConstructor as createRxDocumentWithConstructor } from \"./rx-document.js\";\nimport { runPluginHooks } from \"./hooks.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { getFromMapOrCreate } from \"./plugins/utils/index.js\";\nvar constructorForCollection = new WeakMap();\nexport function getDocumentPrototype(rxCollection) {\n  var schemaProto = rxCollection.schema.getDocumentPrototype();\n  var ormProto = getDocumentOrmPrototype(rxCollection);\n  var baseProto = basePrototype;\n  var proto = {};\n  [schemaProto, ormProto, baseProto].forEach(obj => {\n    var props = Object.getOwnPropertyNames(obj);\n    props.forEach(key => {\n      var desc = Object.getOwnPropertyDescriptor(obj, key);\n      /**\n       * When enumerable is true, it will show on console dir(instance)\n       * To not pollute the output, only getters and methods are enumerable\n       */\n      var enumerable = true;\n      if (key.startsWith('_') || key.endsWith('_') || key.startsWith('$') || key.endsWith('$')) enumerable = false;\n      if (typeof desc.value === 'function') {\n        // when getting a function, we automatically do a .bind(this)\n        Object.defineProperty(proto, key, {\n          get() {\n            return desc.value.bind(this);\n          },\n          enumerable,\n          configurable: false\n        });\n      } else {\n        desc.enumerable = enumerable;\n        desc.configurable = false;\n        if (desc.writable) desc.writable = false;\n        Object.defineProperty(proto, key, desc);\n      }\n    });\n  });\n  return proto;\n}\nexport function getRxDocumentConstructor(rxCollection) {\n  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nexport function createNewRxDocument(rxCollection, documentConstructor, docData) {\n  var doc = createRxDocumentWithConstructor(documentConstructor, rxCollection, overwritable.deepFreezeWhenDevMode(docData));\n  rxCollection._runHooksSync('post', 'create', docData, doc);\n  runPluginHooks('postCreateRxDocument', doc);\n  return doc;\n}\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nexport function getDocumentOrmPrototype(rxCollection) {\n  var proto = {};\n  Object.entries(rxCollection.methods).forEach(([k, v]) => {\n    proto[k] = v;\n  });\n  return proto;\n}\n", "import { deepEqual } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport var defaultConflictHandler = {\n  isEqual(a, b) {\n    /**\n     * If the documents are deep equal,\n     * we have no conflict.\n     * On your custom conflict handler you might only\n     * check some properties, like the updatedAt time,\n     * for better performance, because deepEqual is expensive.\n     */\n    return deepEqual(stripAttachmentsDataFromDocument(a), stripAttachmentsDataFromDocument(b));\n  },\n  resolve(i) {\n    /**\n     * The default conflict handler will always\n     * drop the fork state and use the master state instead.\n     */\n    return i.realMasterState;\n  }\n};\n", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { filter, map, mergeMap } from 'rxjs';\nimport { ucfirst, flatClone, promiseSeries, pluginMissing, ensureNotFalsy, getFromMapOrThrow, PROMISE_RESOLVE_FALSE, PROMISE_RESOLVE_VOID, NON_PREMIUM_COLLECTION_LIMIT, hasPremiumFlag } from \"./plugins/utils/index.js\";\nimport { fillObjectDataBeforeInsert, createRxCollectionStorageInstance, removeCollectionStorages, ensureRxCollectionIsNotClosed } from \"./rx-collection-helper.js\";\nimport { createRxQuery, _getDefaultQuery } from \"./rx-query.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\nimport { DocumentCache, mapDocumentsDataToCacheDocs } from \"./doc-cache.js\";\nimport { createQueryCache, defaultCacheReplacementPolicy } from \"./query-cache.js\";\nimport { createChangeEventBuffer } from \"./change-event-buffer.js\";\nimport { runAsyncPluginHooks, runPluginHooks } from \"./hooks.js\";\nimport { createNewRxDocument, getRxDocumentConstructor } from \"./rx-document-prototype-merge.js\";\nimport { getWrappedStorageInstance, getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from \"./rx-storage-helper.js\";\nimport { IncrementalWriteQueue } from \"./incremental-write.js\";\nimport { beforeDocumentUpdateWrite } from \"./rx-document.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { defaultConflictHandler } from \"./replication-protocol/default-conflict-handler.js\";\nimport { rxChangeEventBulkToRxChangeEvents } from \"./rx-change-event.js\";\nvar HOOKS_WHEN = ['pre', 'post'];\nvar HOOKS_KEYS = ['insert', 'save', 'remove', 'create'];\nvar hooksApplied = false;\nexport var OPEN_COLLECTIONS = new Set();\nexport var RxCollectionBase = /*#__PURE__*/function () {\n  /**\n   * Stores all 'normal' documents\n   */\n\n  /**\n   * Before reads, all these methods are awaited. Used to \"block\" reads\n   * depending on other processes, like when the RxPipeline is running.\n   */\n\n  function RxCollectionBase(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {\n    this.storageInstance = {};\n    this.timeouts = new Set();\n    this.incrementalWriteQueue = {};\n    this.awaitBeforeReads = new Set();\n    this._incrementalUpsertQueues = new Map();\n    this.synced = false;\n    this.hooks = {};\n    this._subs = [];\n    this._docCache = {};\n    this._queryCache = createQueryCache();\n    this.$ = {};\n    this.checkpoint$ = {};\n    this._changeEventBuffer = {};\n    this.eventBulks$ = {};\n    this.onClose = [];\n    this.closed = false;\n    this.onRemove = [];\n    this.database = database;\n    this.name = name;\n    this.schema = schema;\n    this.internalStorageInstance = internalStorageInstance;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.migrationStrategies = migrationStrategies;\n    this.methods = methods;\n    this.attachments = attachments;\n    this.options = options;\n    this.cacheReplacementPolicy = cacheReplacementPolicy;\n    this.statics = statics;\n    this.conflictHandler = conflictHandler;\n    _applyHookFunctions(this.asRxCollection);\n    if (database) {\n      // might be falsy on pseudoInstance\n      this.eventBulks$ = database.eventBulks$.pipe(filter(changeEventBulk => changeEventBulk.collectionName === this.name));\n    } else {}\n\n    /**\n     * Must be last because the hooks might throw on dev-mode\n     * checks and we do not want to have broken collections here.\n     * RxCollection instances created for testings do not have a database\n     * so we do not add these to the list.\n     */\n    if (this.database) {\n      OPEN_COLLECTIONS.add(this);\n    }\n  }\n  var _proto = RxCollectionBase.prototype;\n  _proto.prepare = async function prepare() {\n    if (!(await hasPremiumFlag())) {\n      /**\n       * When used in a test suite, we often open and close many databases with collections\n       * while not awaiting the database.close() call to improve the test times.\n       * So when reopening collections and the OPEN_COLLECTIONS size is full,\n       * we retry after some times to account for this.\n       */\n      var count = 0;\n      while (count < 10 && OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n        count++;\n        await this.promiseWait(30);\n      }\n      if (OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n        throw newRxError('COL23', {\n          database: this.database.name,\n          collection: this.name,\n          args: {\n            existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({\n              db: c.database ? c.database.name : '',\n              c: c.name\n            }))\n          }\n        });\n      }\n    }\n    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);\n    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), result => this._runHooks('post', 'save', result));\n    this.$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)));\n    this.checkpoint$ = this.eventBulks$.pipe(map(changeEventBulk => changeEventBulk.checkpoint));\n    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);\n    var documentConstructor;\n    this._docCache = new DocumentCache(this.schema.primaryPath, this.eventBulks$.pipe(filter(bulk => !bulk.isLocal), map(bulk => bulk.events)), docData => {\n      if (!documentConstructor) {\n        documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n      }\n      return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n    });\n    var listenToRemoveSub = this.database.internalStore.changeStream().pipe(filter(bulk => {\n      var key = this.name + '-' + this.schema.version;\n      var found = bulk.events.find(event => {\n        return event.documentData.context === 'collection' && event.documentData.key === key && event.operation === 'DELETE';\n      });\n      return !!found;\n    })).subscribe(async () => {\n      await this.close();\n      await Promise.all(this.onRemove.map(fn => fn()));\n    });\n    this._subs.push(listenToRemoveSub);\n    var databaseStorageToken = await this.database.storageToken;\n    var subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n      var changeEventBulk = {\n        id: eventBulk.id,\n        isLocal: false,\n        internal: false,\n        collectionName: this.name,\n        storageToken: databaseStorageToken,\n        events: eventBulk.events,\n        databaseToken: this.database.token,\n        checkpoint: eventBulk.checkpoint,\n        context: eventBulk.context\n      };\n      this.database.$emit(changeEventBulk);\n    });\n    this._subs.push(subDocs);\n    return PROMISE_RESOLVE_VOID;\n  }\n\n  /**\n   * Manually call the cleanup function of the storage.\n   * @link https://rxdb.info/cleanup.html\n   */;\n  _proto.cleanup = function cleanup(_minimumDeletedTime) {\n    ensureRxCollectionIsNotClosed(this);\n    throw pluginMissing('cleanup');\n  }\n\n  // overwritten by migration-plugin\n  ;\n  _proto.migrationNeeded = function migrationNeeded() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.getMigrationState = function getMigrationState() {\n    throw pluginMissing('migration-schema');\n  };\n  _proto.startMigration = function startMigration(batchSize = 10) {\n    ensureRxCollectionIsNotClosed(this);\n    return this.getMigrationState().startMigration(batchSize);\n  };\n  _proto.migratePromise = function migratePromise(batchSize = 10) {\n    return this.getMigrationState().migratePromise(batchSize);\n  };\n  _proto.insert = async function insert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var writeResult = await this.bulkInsert([json]);\n    var isError = writeResult.error[0];\n    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);\n    var insertResult = ensureNotFalsy(writeResult.success[0]);\n    return insertResult;\n  };\n  _proto.insertIfNotExists = async function insertIfNotExists(json) {\n    var writeResult = await this.bulkInsert([json]);\n    if (writeResult.error.length > 0) {\n      var error = writeResult.error[0];\n      if (error.status === 409) {\n        var conflictDocData = error.documentInDb;\n        return mapDocumentsDataToCacheDocs(this._docCache, [conflictDocData])[0];\n      } else {\n        throw error;\n      }\n    }\n    return writeResult.success[0];\n  };\n  _proto.bulkInsert = async function bulkInsert(docsData) {\n    ensureRxCollectionIsNotClosed(this);\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n    */\n    if (docsData.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var primaryPath = this.schema.primaryPath;\n    var ids = new Set();\n\n    /**\n     * This code is a bit redundant for better performance.\n     * Instead of iterating multiple times,\n     * we directly transform the input to a write-row array.\n     */\n    var insertRows;\n    if (this.hasHooks('pre', 'insert')) {\n      insertRows = await Promise.all(docsData.map(docData => {\n        var useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n        return this._runHooks('pre', 'insert', useDocData).then(() => {\n          ids.add(useDocData[primaryPath]);\n          return {\n            document: useDocData\n          };\n        });\n      }));\n    } else {\n      insertRows = new Array(docsData.length);\n      var _schema = this.schema;\n      for (var index = 0; index < docsData.length; index++) {\n        var docData = docsData[index];\n        var useDocData = fillObjectDataBeforeInsert(_schema, docData);\n        ids.add(useDocData[primaryPath]);\n        insertRows[index] = {\n          document: useDocData\n        };\n      }\n    }\n    if (ids.size !== docsData.length) {\n      throw newRxError('COL22', {\n        collection: this.name,\n        args: {\n          documents: docsData\n        }\n      });\n    }\n    var results = await this.storageInstance.bulkWrite(insertRows, 'rx-collection-bulk-insert');\n\n    /**\n     * Often the user does not need to access the RxDocuments of the bulkInsert() call.\n     * So we transform the data to RxDocuments only if needed to use less CPU performance.\n     */\n    var rxDocuments;\n    var collection = this;\n    var ret = {\n      get success() {\n        if (!rxDocuments) {\n          var success = getWrittenDocumentsFromBulkWriteResponse(collection.schema.primaryPath, insertRows, results);\n          rxDocuments = mapDocumentsDataToCacheDocs(collection._docCache, success);\n        }\n        return rxDocuments;\n      },\n      error: results.error\n    };\n    if (this.hasHooks('post', 'insert')) {\n      var docsMap = new Map();\n      insertRows.forEach(row => {\n        var doc = row.document;\n        docsMap.set(doc[primaryPath], doc);\n      });\n      await Promise.all(ret.success.map(doc => {\n        return this._runHooks('post', 'insert', docsMap.get(doc.primary), doc);\n      }));\n    }\n    return ret;\n  };\n  _proto.bulkRemove = async function bulkRemove(\n  /**\n   * You can either remove the documents by their ids\n   * or by directly providing the RxDocument instances\n   * if you have them already. This improves performance a bit.\n   */\n  idsOrDocs) {\n    ensureRxCollectionIsNotClosed(this);\n    var primaryPath = this.schema.primaryPath;\n    /**\n     * Optimization shortcut,\n     * do nothing when called with an empty array\n     */\n    if (idsOrDocs.length === 0) {\n      return {\n        success: [],\n        error: []\n      };\n    }\n    var rxDocumentMap;\n    if (typeof idsOrDocs[0] === 'string') {\n      rxDocumentMap = await this.findByIds(idsOrDocs).exec();\n    } else {\n      rxDocumentMap = new Map();\n      idsOrDocs.forEach(d => rxDocumentMap.set(d.primary, d));\n    }\n    var docsData = [];\n    var docsMap = new Map();\n    Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n      var data = rxDocument.toMutableJSON(true);\n      docsData.push(data);\n      docsMap.set(rxDocument.primary, data);\n    });\n    await Promise.all(docsData.map(doc => {\n      var primary = doc[this.schema.primaryPath];\n      return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n    }));\n    var removeDocs = docsData.map(doc => {\n      var writeDoc = flatClone(doc);\n      writeDoc._deleted = true;\n      return {\n        previous: doc,\n        document: writeDoc\n      };\n    });\n    var results = await this.storageInstance.bulkWrite(removeDocs, 'rx-collection-bulk-remove');\n    var success = getWrittenDocumentsFromBulkWriteResponse(this.schema.primaryPath, removeDocs, results);\n    var deletedRxDocuments = [];\n    var successIds = success.map(d => {\n      var id = d[primaryPath];\n      var doc = this._docCache.getCachedRxDocument(d);\n      deletedRxDocuments.push(doc);\n      return id;\n    });\n\n    // run hooks\n    await Promise.all(successIds.map(id => {\n      return this._runHooks('post', 'remove', docsMap.get(id), rxDocumentMap.get(id));\n    }));\n    return {\n      success: deletedRxDocuments,\n      error: results.error\n    };\n  }\n\n  /**\n   * same as bulkInsert but overwrites existing document with same primary\n   */;\n  _proto.bulkUpsert = async function bulkUpsert(docsData) {\n    ensureRxCollectionIsNotClosed(this);\n    var insertData = [];\n    var useJsonByDocId = new Map();\n    docsData.forEach(docData => {\n      var useJson = fillObjectDataBeforeInsert(this.schema, docData);\n      var primary = useJson[this.schema.primaryPath];\n      if (!primary) {\n        throw newRxError('COL3', {\n          primaryPath: this.schema.primaryPath,\n          data: useJson,\n          schema: this.schema.jsonSchema\n        });\n      }\n      useJsonByDocId.set(primary, useJson);\n      insertData.push(useJson);\n    });\n    var insertResult = await this.bulkInsert(insertData);\n    var success = insertResult.success.slice(0);\n    var error = [];\n\n    // update the ones that existed already\n    await Promise.all(insertResult.error.map(async err => {\n      if (err.status !== 409) {\n        error.push(err);\n      } else {\n        var id = err.documentId;\n        var writeData = getFromMapOrThrow(useJsonByDocId, id);\n        var docDataInDb = ensureNotFalsy(err.documentInDb);\n        var doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n        var newDoc = await doc.incrementalModify(() => writeData);\n        success.push(newDoc);\n      }\n    }));\n    return {\n      error,\n      success\n    };\n  }\n\n  /**\n   * same as insert but overwrites existing document with same primary\n   */;\n  _proto.upsert = async function upsert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var bulkResult = await this.bulkUpsert([json]);\n    throwIfIsStorageWriteError(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);\n    return bulkResult.success[0];\n  }\n\n  /**\n   * upserts to a RxDocument, uses incrementalModify if document already exists\n   */;\n  _proto.incrementalUpsert = function incrementalUpsert(json) {\n    ensureRxCollectionIsNotClosed(this);\n    var useJson = fillObjectDataBeforeInsert(this.schema, json);\n    var primary = useJson[this.schema.primaryPath];\n    if (!primary) {\n      throw newRxError('COL4', {\n        data: json\n      });\n    }\n\n    // ensure that it won't try 2 parallel runs\n    var queue = this._incrementalUpsertQueues.get(primary);\n    if (!queue) {\n      queue = PROMISE_RESOLVE_VOID;\n    }\n    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then(wasInserted => {\n      if (!wasInserted.inserted) {\n        return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n      } else {\n        return wasInserted.doc;\n      }\n    });\n    this._incrementalUpsertQueues.set(primary, queue);\n    return queue;\n  };\n  _proto.find = function find(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    runPluginHooks('prePrepareRxQuery', {\n      op: 'find',\n      queryObj,\n      collection: this\n    });\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('find', queryObj, this);\n    return query;\n  };\n  _proto.findOne = function findOne(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    runPluginHooks('prePrepareRxQuery', {\n      op: 'findOne',\n      queryObj,\n      collection: this\n    });\n    var query;\n    if (typeof queryObj === 'string') {\n      query = createRxQuery('findOne', {\n        selector: {\n          [this.schema.primaryPath]: queryObj\n        },\n        limit: 1\n      }, this);\n    } else {\n      if (!queryObj) {\n        queryObj = _getDefaultQuery();\n      }\n\n      // cannot have limit on findOne queries because it will be overwritten\n      if (queryObj.limit) {\n        throw newRxError('QU6');\n      }\n      queryObj = flatClone(queryObj);\n      queryObj.limit = 1;\n      query = createRxQuery('findOne', queryObj, this);\n    }\n    return query;\n  };\n  _proto.count = function count(queryObj) {\n    ensureRxCollectionIsNotClosed(this);\n    if (!queryObj) {\n      queryObj = _getDefaultQuery();\n    }\n    var query = createRxQuery('count', queryObj, this);\n    return query;\n  }\n\n  /**\n   * find a list documents by their primary key\n   * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n   */;\n  _proto.findByIds = function findByIds(ids) {\n    ensureRxCollectionIsNotClosed(this);\n    var mangoQuery = {\n      selector: {\n        [this.schema.primaryPath]: {\n          $in: ids.slice(0)\n        }\n      }\n    };\n    var query = createRxQuery('findByIds', mangoQuery, this);\n    return query;\n  }\n\n  /**\n   * Export collection to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON() {\n    throw pluginMissing('json-dump');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.insertCRDT = function insertCRDT(_updateObj) {\n    throw pluginMissing('crdt');\n  };\n  _proto.addPipeline = function addPipeline(_options) {\n    throw pluginMissing('pipeline');\n  }\n\n  /**\n   * HOOKS\n   */;\n  _proto.addHook = function addHook(when, key, fun, parallel = false) {\n    if (typeof fun !== 'function') {\n      throw newRxTypeError('COL7', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_WHEN.includes(when)) {\n      throw newRxTypeError('COL8', {\n        key,\n        when\n      });\n    }\n    if (!HOOKS_KEYS.includes(key)) {\n      throw newRxError('COL9', {\n        key\n      });\n    }\n    if (when === 'post' && key === 'create' && parallel === true) {\n      throw newRxError('COL10', {\n        when,\n        key,\n        parallel\n      });\n    }\n\n    // bind this-scope to hook-function\n    var boundFun = fun.bind(this);\n    var runName = parallel ? 'parallel' : 'series';\n    this.hooks[key] = this.hooks[key] || {};\n    this.hooks[key][when] = this.hooks[key][when] || {\n      series: [],\n      parallel: []\n    };\n    this.hooks[key][when][runName].push(boundFun);\n  };\n  _proto.getHooks = function getHooks(when, key) {\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return {\n        series: [],\n        parallel: []\n      };\n    }\n    return this.hooks[key][when];\n  };\n  _proto.hasHooks = function hasHooks(when, key) {\n    /**\n     * Performance shortcut\n     * so that we not have to build the empty object.\n     */\n    if (!this.hooks[key] || !this.hooks[key][when]) {\n      return false;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return false;\n    }\n    return hooks.series.length > 0 || hooks.parallel.length > 0;\n  };\n  _proto._runHooks = function _runHooks(when, key, data, instance) {\n    var hooks = this.getHooks(when, key);\n    if (!hooks) {\n      return PROMISE_RESOLVE_VOID;\n    }\n\n    // run parallel: false\n    var tasks = hooks.series.map(hook => () => hook(data, instance));\n    return promiseSeries(tasks)\n    // run parallel: true\n    .then(() => Promise.all(hooks.parallel.map(hook => hook(data, instance))));\n  }\n\n  /**\n   * does the same as ._runHooks() but with non-async-functions\n   */;\n  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {\n    if (!this.hasHooks(when, key)) {\n      return;\n    }\n    var hooks = this.getHooks(when, key);\n    if (!hooks) return;\n    hooks.series.forEach(hook => hook(data, instance));\n  }\n\n  /**\n   * Returns a promise that resolves after the given time.\n   * Ensures that is properly cleans up when the collection is closed\n   * so that no running timeouts prevent the exit of the JavaScript process.\n   */;\n  _proto.promiseWait = function promiseWait(time) {\n    var ret = new Promise(res => {\n      var timeout = setTimeout(() => {\n        this.timeouts.delete(timeout);\n        res();\n      }, time);\n      this.timeouts.add(timeout);\n    });\n    return ret;\n  };\n  _proto.close = async function close() {\n    if (this.closed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n    OPEN_COLLECTIONS.delete(this);\n    await Promise.all(this.onClose.map(fn => fn()));\n\n    /**\n     * Settings closed = true\n     * must be the first thing to do,\n     * so for example the replication can directly stop\n     * instead of sending requests to a closed storage.\n     */\n    this.closed = true;\n    Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n    if (this._changeEventBuffer) {\n      this._changeEventBuffer.close();\n    }\n    /**\n     * First wait until the whole database is idle.\n     * This ensures that the storage does not get closed\n     * while some operation is running.\n     * It is important that we do not intercept a running call\n     * because it might lead to undefined behavior like when a doc is written\n     * but the change is not added to the changes collection.\n     */\n    return this.database.requestIdlePromise().then(() => this.storageInstance.close()).then(() => {\n      /**\n       * Unsubscribing must be done AFTER the storageInstance.close()\n       * Because the conflict handling is part of the subscriptions and\n       * otherwise there might be open conflicts to be resolved which\n       * will then stuck and never resolve.\n       */\n      this._subs.forEach(sub => sub.unsubscribe());\n      delete this.database.collections[this.name];\n      return runAsyncPluginHooks('postCloseRxCollection', this).then(() => true);\n    });\n  }\n\n  /**\n   * remove all data of the collection\n   */;\n  _proto.remove = async function remove() {\n    await this.close();\n    await Promise.all(this.onRemove.map(fn => fn()));\n    /**\n     * TODO here we should pass the already existing\n     * storage instances instead of creating new ones.\n     */\n    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.multiInstance, this.database.password, this.database.hashFunction);\n  };\n  return _createClass(RxCollectionBase, [{\n    key: \"insert$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'INSERT'));\n    }\n  }, {\n    key: \"update$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'UPDATE'));\n    }\n  }, {\n    key: \"remove$\",\n    get: function () {\n      return this.$.pipe(filter(cE => cE.operation === 'DELETE'));\n    }\n\n    // defaults\n\n    /**\n     * Internally only use eventBulks$\n     * Do not use .$ or .observable$ because that has to transform\n     * the events which decreases performance.\n     */\n\n    /**\n     * When the collection is closed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n  }, {\n    key: \"asRxCollection\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(collection) {\n  if (hooksApplied) return; // already run\n  hooksApplied = true;\n  var colProto = Object.getPrototypeOf(collection);\n  HOOKS_KEYS.forEach(key => {\n    HOOKS_WHEN.map(when => {\n      var fnName = when + ucfirst(key);\n      colProto[fnName] = function (fun, parallel) {\n        return this.addHook(when, key, fun, parallel);\n      };\n    });\n  });\n}\nfunction _incrementalUpsertUpdate(doc, json) {\n  return doc.incrementalModify(_innerDoc => {\n    return json;\n  });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {\n  /**\n   * Optimisation shortcut,\n   * first try to find the document in the doc-cache\n   */\n  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n  if (docDataFromCache) {\n    return Promise.resolve({\n      doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n      inserted: false\n    });\n  }\n  return rxCollection.findOne(primary).exec().then(doc => {\n    if (!doc) {\n      return rxCollection.insert(json).then(newDoc => ({\n        doc: newDoc,\n        inserted: true\n      }));\n    } else {\n      return {\n        doc,\n        inserted: false\n      };\n    }\n  });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection({\n  database,\n  name,\n  schema,\n  instanceCreationOptions = {},\n  migrationStrategies = {},\n  autoMigrate = true,\n  statics = {},\n  methods = {},\n  attachments = {},\n  options = {},\n  localDocuments = false,\n  cacheReplacementPolicy = defaultCacheReplacementPolicy,\n  conflictHandler = defaultConflictHandler\n}) {\n  var storageInstanceCreationParams = {\n    databaseInstanceToken: database.token,\n    databaseName: database.name,\n    collectionName: name,\n    schema: schema.jsonSchema,\n    options: instanceCreationOptions,\n    multiInstance: database.multiInstance,\n    password: database.password,\n    devMode: overwritable.isDevMode()\n  };\n  runPluginHooks('preCreateRxStorageInstance', storageInstanceCreationParams);\n  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then(storageInstance => {\n    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);\n    return collection.prepare().then(() => {\n      // ORM add statics\n      Object.entries(statics).forEach(([funName, fun]) => {\n        Object.defineProperty(collection, funName, {\n          get: () => fun.bind(collection)\n        });\n      });\n      var ret = PROMISE_RESOLVE_VOID;\n      if (autoMigrate && collection.schema.version !== 0) {\n        ret = collection.migratePromise();\n      }\n      return ret;\n    }).then(() => {\n      runPluginHooks('createRxCollection', {\n        collection,\n        creator: {\n          name,\n          schema,\n          storageInstance,\n          instanceCreationOptions,\n          migrationStrategies,\n          methods,\n          attachments,\n          options,\n          cacheReplacementPolicy,\n          localDocuments,\n          statics\n        }\n      });\n      return collection;\n    })\n    /**\n     * If the collection creation fails,\n     * we yet have to close the storage instances.\n     */.catch(err => {\n      OPEN_COLLECTIONS.delete(collection);\n      return storageInstance.close().then(() => Promise.reject(err));\n    });\n  });\n}\nexport function isRxCollection(obj) {\n  return obj instanceof RxCollectionBase;\n}\n", "/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n    _tryIdleCall(this);\n  },\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n    this.lock();\n    var maybePromise;\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n        throw err;\n      });\n    }\n  },\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n      resolve();\n    };\n    prom._manRes = resolveFromOutside;\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n    this._iC.add(prom);\n    _tryIdleCall(this);\n    return prom;\n  },\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n    this._hPM.set(handle, promise);\n    this._pHM.set(promise, handle);\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n    this.cancelIdlePromise(promise);\n  },\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n    this._qC = 0;\n    this._iC.clear();\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n  var iterator = idleQueue._iC.values();\n  var oldestPromise = iterator.next().value;\n  oldestPromise._manRes(); // try to call the next tick\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n    idleQueue._hPM[\"delete\"](handle);\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n      _resolveOneIdleCall(idleQueue);\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}", "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport { IdleQueue } from 'custom-idle-queue';\nimport { ObliviousSet } from 'oblivious-set';\nimport { pluginMissing, flatClone, PROMISE_RESOLVE_FALSE, randomToken, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, defaultHashSha256, RXDB_VERSION } from \"./plugins/utils/index.js\";\nimport { newRxError } from \"./rx-error.js\";\nimport { createRxSchema } from \"./rx-schema.js\";\nimport { runPluginHooks, runAsyncPluginHooks } from \"./hooks.js\";\nimport { Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { createRxCollection } from \"./rx-collection.js\";\nimport { flatCloneDocWithMeta, getSingleDocument, getWrappedStorageInstance, INTERNAL_STORAGE_NAME } from \"./rx-storage-helper.js\";\nimport { ensureStorageTokenDocumentExists, getAllCollectionDocuments, getPrimaryKeyOfInternalDocument, INTERNAL_CONTEXT_COLLECTION, INTERNAL_STORE_SCHEMA, _collectionNamePrimary } from \"./rx-database-internal-store.js\";\nimport { removeCollectionStorages } from \"./rx-collection-helper.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { rxChangeEventBulkToRxChangeEvents } from \"./rx-change-event.js\";\n\n/**\n * stores the used database names+storage names\n * so we can throw when the same database is created more then once.\n */\nvar USED_DATABASE_NAMES = new Set();\nvar DB_COUNT = 0;\nexport var RxDatabaseBase = /*#__PURE__*/function () {\n  /**\n   * Contains all known non-closed storage instances\n   * that belong to this database.\n   * Used in plugins and unit tests.\n   */\n\n  function RxDatabaseBase(name,\n  /**\n   * Uniquely identifies the instance\n   * of this RxDatabase.\n   */\n  token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {},\n  /**\n   * Stores information documents about the collections of the database\n   */\n  internalStore, hashFunction, cleanupPolicy, allowSlowCount, reactivity) {\n    this.idleQueue = new IdleQueue();\n    this.rxdbVersion = RXDB_VERSION;\n    this.storageInstances = new Set();\n    this._subs = [];\n    this.startupErrors = [];\n    this.onClose = [];\n    this.closed = false;\n    this.collections = {};\n    this.states = {};\n    this.eventBulks$ = new Subject();\n    this.observable$ = this.eventBulks$.pipe(mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)));\n    this.storageToken = PROMISE_RESOLVE_FALSE;\n    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;\n    this.emittedEventBulkIds = new ObliviousSet(60 * 1000);\n    this.name = name;\n    this.token = token;\n    this.storage = storage;\n    this.instanceCreationOptions = instanceCreationOptions;\n    this.password = password;\n    this.multiInstance = multiInstance;\n    this.eventReduce = eventReduce;\n    this.options = options;\n    this.internalStore = internalStore;\n    this.hashFunction = hashFunction;\n    this.cleanupPolicy = cleanupPolicy;\n    this.allowSlowCount = allowSlowCount;\n    this.reactivity = reactivity;\n    DB_COUNT++;\n\n    /**\n     * In the dev-mode, we create a pseudoInstance\n     * to get all properties of RxDatabase and ensure they do not\n     * conflict with the collection names etc.\n     * So only if it is not pseudoInstance,\n     * we have all values to prepare a real RxDatabase.\n     *\n     * TODO this is ugly, we should use a different way in the dev-mode\n     * so that all non-dev-mode code can be cleaner.\n     */\n    if (this.name !== 'pseudoInstance') {\n      /**\n       * Wrap the internal store\n       * to ensure that calls to it also end up in\n       * calculation of the idle state and the hooks.\n       */\n      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);\n\n      /**\n       * Start writing the storage token.\n       * Do not await the creation because it would run\n       * in a critical path that increases startup time.\n       *\n       * Writing the token takes about 20 milliseconds\n       * even on a fast adapter, so this is worth it.\n       */\n      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch(err => this.startupErrors.push(err));\n      this.storageToken = this.storageTokenDocument.then(doc => doc.data.token).catch(err => this.startupErrors.push(err));\n    }\n  }\n  var _proto = RxDatabaseBase.prototype;\n  _proto.getReactivityFactory = function getReactivityFactory() {\n    if (!this.reactivity) {\n      throw newRxError('DB14', {\n        database: this.name\n      });\n    }\n    return this.reactivity;\n  }\n\n  /**\n   * Because having unhandled exceptions would fail,\n   * we have to store the async errors of the constructor here\n   * so we can throw them later.\n   */\n\n  /**\n   * When the database is closed,\n   * these functions will be called an awaited.\n   * Used to automatically clean up stuff that\n   * belongs to this collection.\n   */\n\n  /**\n   * Internally only use eventBulks$\n   * Do not use .$ or .observable$ because that has to transform\n   * the events which decreases performance.\n   */\n\n  /**\n   * Unique token that is stored with the data.\n   * Used to detect if the dataset has been deleted\n   * and if two RxDatabase instances work on the same dataset or not.\n   *\n   * Because reading and writing the storageToken runs in the hot path\n   * of database creation, we do not await the storageWrites but instead\n   * work with the promise when we need the value.\n   */\n\n  /**\n   * Stores the whole state of the internal storage token document.\n   * We need this in some plugins.\n   */\n\n  /**\n   * Contains the ids of all event bulks that have been emitted\n   * by the database.\n   * Used to detect duplicates that come in again via BroadcastChannel\n   * or other streams.\n   * In the past we tried to remove this and to ensure\n   * all storages only emit the same event bulks only once\n   * but it turns out this is just not possible for all storages.\n   * JavaScript processes, workers and browser tabs can be closed and started at any time\n   * which can cause cases where it is not possible to know if an event bulk has been emitted already.\n   */;\n  /**\n   * This is the main handle-point for all change events\n   * ChangeEvents created by this instance go:\n   * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n   * ChangeEvents created by other instances go:\n   * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n   */\n  _proto.$emit = function $emit(changeEventBulk) {\n    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n      return;\n    }\n    this.emittedEventBulkIds.add(changeEventBulk.id);\n    this.eventBulks$.next(changeEventBulk);\n  }\n\n  /**\n   * removes the collection-doc from the internalStore\n   */;\n  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {\n    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));\n    if (!doc) {\n      throw newRxError('SNH', {\n        name,\n        schema\n      });\n    }\n    var writeDoc = flatCloneDocWithMeta(doc);\n    writeDoc._deleted = true;\n    await this.internalStore.bulkWrite([{\n      document: writeDoc,\n      previous: doc\n    }], 'rx-database-remove-collection');\n  }\n\n  /**\n   * creates multiple RxCollections at once\n   * to be much faster by saving db txs and doing stuff in bulk-operations\n   * This function is not called often, but mostly in the critical path at the initial page load\n   * So it must be as fast as possible.\n   */;\n  _proto.addCollections = async function addCollections(collectionCreators) {\n    var jsonSchemas = {};\n    var schemas = {};\n    var bulkPutDocs = [];\n    var useArgsByCollectionName = {};\n    await Promise.all(Object.entries(collectionCreators).map(async ([name, args]) => {\n      var collectionName = name;\n      var rxJsonSchema = args.schema;\n      jsonSchemas[collectionName] = rxJsonSchema;\n      var schema = createRxSchema(rxJsonSchema, this.hashFunction);\n      schemas[collectionName] = schema;\n\n      // collection already exists\n      if (this.collections[name]) {\n        throw newRxError('DB3', {\n          name\n        });\n      }\n      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n      var collectionDocData = {\n        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),\n        key: collectionNameWithVersion,\n        context: INTERNAL_CONTEXT_COLLECTION,\n        data: {\n          name: collectionName,\n          schemaHash: await schema.hash,\n          schema: schema.jsonSchema,\n          version: schema.version,\n          connectedStorages: []\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n      };\n      bulkPutDocs.push({\n        document: collectionDocData\n      });\n      var useArgs = Object.assign({}, args, {\n        name: collectionName,\n        schema,\n        database: this\n      });\n\n      // run hooks\n      var hookData = flatClone(args);\n      hookData.database = this;\n      hookData.name = name;\n      runPluginHooks('preCreateRxCollection', hookData);\n      useArgs.conflictHandler = hookData.conflictHandler;\n      useArgsByCollectionName[collectionName] = useArgs;\n    }));\n    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, 'rx-database-add-collection');\n    await ensureNoStartupErrors(this);\n    await Promise.all(putDocsResult.error.map(async error => {\n      if (error.status !== 409) {\n        throw newRxError('DB12', {\n          database: this.name,\n          writeError: error\n        });\n      }\n      var docInDb = ensureNotFalsy(error.documentInDb);\n      var collectionName = docInDb.data.name;\n      var schema = schemas[collectionName];\n      // collection already exists but has different schema\n      if (docInDb.data.schemaHash !== (await schema.hash)) {\n        throw newRxError('DB6', {\n          database: this.name,\n          collection: collectionName,\n          previousSchemaHash: docInDb.data.schemaHash,\n          schemaHash: await schema.hash,\n          previousSchema: docInDb.data.schema,\n          schema: ensureNotFalsy(jsonSchemas[collectionName])\n        });\n      }\n    }));\n    var ret = {};\n    await Promise.all(Object.keys(collectionCreators).map(async collectionName => {\n      var useArgs = useArgsByCollectionName[collectionName];\n      var collection = await createRxCollection(useArgs);\n      ret[collectionName] = collection;\n\n      // set as getter to the database\n      this.collections[collectionName] = collection;\n      if (!this[collectionName]) {\n        Object.defineProperty(this, collectionName, {\n          get: () => this.collections[collectionName]\n        });\n      }\n    }));\n    return ret;\n  }\n\n  /**\n   * runs the given function between idleQueue-locking\n   */;\n  _proto.lockedRun = function lockedRun(fn) {\n    return this.idleQueue.wrapCall(fn);\n  };\n  _proto.requestIdlePromise = function requestIdlePromise() {\n    return this.idleQueue.requestIdlePromise();\n  }\n\n  /**\n   * Export database to a JSON friendly format.\n   */;\n  _proto.exportJSON = function exportJSON(_collections) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.addState = function addState(_name) {\n    throw pluginMissing('state');\n  }\n\n  /**\n   * Import the parsed JSON export into the collection.\n   * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n   * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n   * since data could be encrypted.\n   */;\n  _proto.importJSON = function importJSON(_exportedJSON) {\n    throw pluginMissing('json-dump');\n  };\n  _proto.backup = function backup(_options) {\n    throw pluginMissing('backup');\n  };\n  _proto.leaderElector = function leaderElector() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.isLeader = function isLeader() {\n    throw pluginMissing('leader-election');\n  }\n  /**\n   * returns a promise which resolves when the instance becomes leader\n   */;\n  _proto.waitForLeadership = function waitForLeadership() {\n    throw pluginMissing('leader-election');\n  };\n  _proto.migrationStates = function migrationStates() {\n    throw pluginMissing('migration-schema');\n  }\n\n  /**\n   * closes the database-instance and all collections\n   */;\n  _proto.close = async function close() {\n    if (this.closed) {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    // settings closed = true must be the first thing to do.\n    this.closed = true;\n    await runAsyncPluginHooks('preCloseRxDatabase', this);\n    /**\n     * Complete the event stream\n     * to stop all subscribers who forgot to unsubscribe.\n     */\n    this.eventBulks$.complete();\n    DB_COUNT--;\n    this._subs.map(sub => sub.unsubscribe());\n\n    /**\n     * closing the pseudo instance will throw\n     * because stuff is missing\n     * TODO we should not need the pseudo instance on runtime.\n     * we should generate the property list on build time.\n     */\n    if (this.name === 'pseudoInstance') {\n      return PROMISE_RESOLVE_FALSE;\n    }\n\n    /**\n     * First wait until the database is idle\n     */\n    return this.requestIdlePromise().then(() => Promise.all(this.onClose.map(fn => fn())))\n    // close all collections\n    .then(() => Promise.all(Object.keys(this.collections).map(key => this.collections[key]).map(col => col.close())))\n    // close internal storage instances\n    .then(() => this.internalStore.close())\n    // remove combination from USED_COMBINATIONS-map\n    .then(() => USED_DATABASE_NAMES.delete(this.storage.name + '|' + this.name)).then(() => true);\n  }\n\n  /**\n   * deletes the database and its stored data.\n   * Returns the names of all removed collections.\n   */;\n  _proto.remove = function remove() {\n    return this.close().then(() => removeRxDatabase(this.name, this.storage, this.multiInstance, this.password));\n  };\n  return _createClass(RxDatabaseBase, [{\n    key: \"$\",\n    get: function () {\n      return this.observable$;\n    }\n  }, {\n    key: \"asRxDatabase\",\n    get: function () {\n      return this;\n    }\n  }]);\n}();\n\n/**\n * checks if an instance with same name and storage already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(name, storage) {\n  var key = storage.name + '|' + name;\n  if (!USED_DATABASE_NAMES.has(key)) {\n    return;\n  } else {\n    throw newRxError('DB8', {\n      name,\n      storage: storage.name,\n      link: 'https://rxdb.info/rx-database.html#ignoreduplicate'\n    });\n  }\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {\n  var internalStore = await storage.createStorageInstance({\n    databaseInstanceToken,\n    databaseName,\n    collectionName: INTERNAL_STORAGE_NAME,\n    schema: INTERNAL_STORE_SCHEMA,\n    options,\n    multiInstance,\n    password,\n    devMode: overwritable.isDevMode()\n  });\n  return internalStore;\n}\nexport function createRxDatabase({\n  storage,\n  instanceCreationOptions,\n  name,\n  password,\n  multiInstance = true,\n  eventReduce = true,\n  ignoreDuplicate = false,\n  options = {},\n  cleanupPolicy,\n  allowSlowCount = false,\n  localDocuments = false,\n  hashFunction = defaultHashSha256,\n  reactivity\n}) {\n  runPluginHooks('preCreateRxDatabase', {\n    storage,\n    instanceCreationOptions,\n    name,\n    password,\n    multiInstance,\n    eventReduce,\n    ignoreDuplicate,\n    options,\n    localDocuments\n  });\n  // check if combination already used\n  if (!ignoreDuplicate) {\n    throwIfDatabaseNameUsed(name, storage);\n  } else {\n    if (!overwritable.isDevMode()) {\n      throw newRxError('DB9', {\n        database: name\n      });\n    }\n  }\n  USED_DATABASE_NAMES.add(storage.name + '|' + name);\n  var databaseInstanceToken = randomToken(10);\n  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password)\n  /**\n   * Creating the internal store might fail\n   * if some RxStorage wrapper is used that does some checks\n   * and then throw.\n   * In that case we have to properly clean up the database.\n   */.catch(err => {\n    USED_DATABASE_NAMES.delete(storage.name + '|' + name);\n    throw err;\n  }).then(storageInstance => {\n    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount, reactivity);\n    return runAsyncPluginHooks('createRxDatabase', {\n      database: rxDatabase,\n      creator: {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n      }\n    }).then(() => rxDatabase);\n  });\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(databaseName, storage, multiInstance = true, password) {\n  var databaseInstanceToken = randomToken(10);\n  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, multiInstance, password);\n  var collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);\n  var collectionNames = new Set();\n  collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n  var removedCollectionNames = Array.from(collectionNames);\n  await Promise.all(removedCollectionNames.map(collectionName => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, multiInstance, password)));\n  await runAsyncPluginHooks('postRemoveRxDatabase', {\n    databaseName,\n    storage\n  });\n  await dbInternalsStorageInstance.remove();\n  return removedCollectionNames;\n}\nexport function isRxDatabase(obj) {\n  return obj instanceof RxDatabaseBase;\n}\nexport function dbCount() {\n  return DB_COUNT;\n}\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(database) {\n  var tokenDoc = await database.storageTokenDocument;\n  return tokenDoc.data.instanceToken === database.token;\n}\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(rxDatabase) {\n  await rxDatabase.storageToken;\n  if (rxDatabase.startupErrors[0]) {\n    throw rxDatabase.startupErrors[0];\n  }\n}\n", "/**\n * this handles how plugins are added to rxdb\n * basically it changes the internal prototypes\n * by passing them to the plugins-functions\n */\nimport { RxSchema } from \"./rx-schema.js\";\nimport { basePrototype as RxDocumentPrototype } from \"./rx-document.js\";\nimport { RxQueryBase } from \"./rx-query.js\";\nimport { RxCollectionBase } from \"./rx-collection.js\";\nimport { RxDatabaseBase } from \"./rx-database.js\";\nimport { overwritable } from \"./overwritable.js\";\nimport { HOOKS, runPluginHooks } from \"./hooks.js\";\nimport { newRxError, newRxTypeError } from \"./rx-error.js\";\n\n/**\n * prototypes that can be manipulated with a plugin\n */\nvar PROTOTYPES = {\n  RxSchema: RxSchema.prototype,\n  RxDocument: RxDocumentPrototype,\n  RxQuery: RxQueryBase.prototype,\n  RxCollection: RxCollectionBase.prototype,\n  RxDatabase: RxDatabaseBase.prototype\n};\nvar ADDED_PLUGINS = new Set();\nvar ADDED_PLUGIN_NAMES = new Set();\n\n/**\n * Add a plugin to the RxDB library.\n * Plugins are added globally and cannot be removed.\n */\nexport function addRxPlugin(plugin) {\n  runPluginHooks('preAddRxPlugin', {\n    plugin,\n    plugins: ADDED_PLUGINS\n  });\n\n  // do nothing if added before\n  if (ADDED_PLUGINS.has(plugin)) {\n    return;\n  } else {\n    // ensure no other plugin with the same name was already added\n    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {\n      throw newRxError('PL3', {\n        name: plugin.name,\n        plugin\n      });\n    }\n    ADDED_PLUGINS.add(plugin);\n    ADDED_PLUGIN_NAMES.add(plugin.name);\n  }\n\n  /**\n   * To identify broken configurations,\n   * we only allow RxDB plugins to be passed into addRxPlugin().\n   */\n  if (!plugin.rxdb) {\n    throw newRxTypeError('PL1', {\n      plugin\n    });\n  }\n  if (plugin.init) {\n    plugin.init();\n  }\n\n  // prototype-overwrites\n  if (plugin.prototypes) {\n    Object.entries(plugin.prototypes).forEach(([name, fun]) => {\n      return fun(PROTOTYPES[name]);\n    });\n  }\n  // overwritable-overwrites\n  if (plugin.overwritable) {\n    Object.assign(overwritable, plugin.overwritable);\n  }\n  // extend-hooks\n  if (plugin.hooks) {\n    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {\n      if (hooksObj.after) {\n        HOOKS[name].push(hooksObj.after);\n      }\n      if (hooksObj.before) {\n        HOOKS[name].unshift(hooksObj.before);\n      }\n    });\n  }\n}\n", "import { getComposedPrimaryKeyOfDocumentData } from \"../rx-schema-helper.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { createRevision, ensureNotFalsy, getDefaultRevision, getDefaultRxDocumentMeta, now } from \"../plugins/utils/index.js\";\nexport async function getLastCheckpointDoc(state, direction) {\n  var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n    isCheckpoint: '1',\n    itemId: direction\n  });\n  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);\n  var checkpointDoc = checkpointResult[0];\n  state.lastCheckpointDoc[direction] = checkpointDoc;\n  if (checkpointDoc) {\n    return checkpointDoc.checkpointData;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint(state, direction, checkpoint) {\n  state.checkpointQueue = state.checkpointQueue.then(async () => {\n    var previousCheckpointDoc = state.lastCheckpointDoc[direction];\n    if (checkpoint &&\n    /**\n     * If the replication is already canceled,\n     * we do not write a checkpoint\n     * because that could mean we write a checkpoint\n     * for data that has been fetched from the master\n     * but not been written to the child.\n     */\n    !state.events.canceled.getValue() && (\n    /**\n     * Only write checkpoint if it is different from before\n     * to have less writes to the storage.\n     */\n\n    !previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint))) {\n      var newDoc = {\n        id: '',\n        isCheckpoint: '1',\n        itemId: direction,\n        _deleted: false,\n        _attachments: {},\n        checkpointData: checkpoint,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision()\n      };\n      newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);\n      while (!state.events.canceled.getValue()) {\n        /**\n         * Instead of just storing the new checkpoint,\n         * we have to stack up the checkpoint with the previous one.\n         * This is required for plugins like the sharding RxStorage\n         * where the changeStream events only contain a Partial of the\n         * checkpoint.\n         */\n        if (previousCheckpointDoc) {\n          newDoc.checkpointData = stackCheckpoints([previousCheckpointDoc.checkpointData, newDoc.checkpointData]);\n        }\n        newDoc._meta.lwt = now();\n        newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n        if (state.events.canceled.getValue()) {\n          return;\n        }\n        var writeRows = [{\n          previous: previousCheckpointDoc,\n          document: newDoc\n        }];\n        var result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');\n        var successDoc = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRows, result)[0];\n        if (successDoc) {\n          state.lastCheckpointDoc[direction] = successDoc;\n          return;\n        } else {\n          var error = result.error[0];\n          if (error.status !== 409) {\n            throw error;\n          } else {\n            previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n            newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);\n          }\n        }\n      }\n    }\n  });\n  await state.checkpointQueue;\n}\nexport async function getCheckpointKey(input) {\n  var hash = await input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join('||'));\n  return 'rx_storage_replication_' + hash;\n}\n", "import { clone, createRevision, flatClone, getDefaultRevision, now } from \"../plugins/utils/index.js\";\nimport { stripAttachmentsDataFromDocument } from \"../rx-storage-helper.js\";\nexport function docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, docState, previous) {\n  var docData = Object.assign({}, docState, {\n    _attachments: hasAttachments && docState._attachments ? docState._attachments : {},\n    _meta: keepMeta ? docState._meta : Object.assign({}, previous ? previous._meta : {}, {\n      lwt: now()\n    }),\n    _rev: keepMeta ? docState._rev : getDefaultRevision()\n  });\n  if (!docData._rev) {\n    docData._rev = createRevision(databaseInstanceToken, previous);\n  }\n  return docData;\n}\nexport function writeDocToDocState(writeDoc, keepAttachments, keepMeta) {\n  var ret = flatClone(writeDoc);\n  if (!keepAttachments) {\n    delete ret._attachments;\n  }\n  if (!keepMeta) {\n    delete ret._meta;\n    delete ret._rev;\n  }\n  return ret;\n}\nexport function stripAttachmentsDataFromMetaWriteRows(state, rows) {\n  if (!state.hasAttachments) {\n    return rows;\n  }\n  return rows.map(row => {\n    var document = clone(row.document);\n    document.docData = stripAttachmentsDataFromDocument(document.docData);\n    return {\n      document,\n      previous: row.previous\n    };\n  });\n}\nexport function getUnderlyingPersistentStorage(instance) {\n  while (true) {\n    if (instance.underlyingPersistentStorage) {\n      instance = instance.underlyingPersistentStorage;\n    } else {\n      return instance;\n    }\n  }\n}\n", "import { fillWithDefaultSettings, getComposedPrimaryKeyOfDocumentData, getLengthOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { flatCloneDocWithMeta } from \"../rx-storage-helper.js\";\nimport { getDefaultRevision, createRevision, now } from \"../plugins/utils/index.js\";\nexport var META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';\nexport function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {\n  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n  var baseSchema = {\n    title: META_INSTANCE_SCHEMA_TITLE,\n    primaryKey: {\n      key: 'id',\n      fields: ['itemId', 'isCheckpoint'],\n      separator: '|'\n    },\n    type: 'object',\n    version: replicatedDocumentsSchema.version,\n    additionalProperties: false,\n    properties: {\n      id: {\n        type: 'string',\n        minLength: 1,\n        // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n        maxLength: parentPrimaryKeyLength + 2\n      },\n      isCheckpoint: {\n        type: 'string',\n        enum: ['0', '1'],\n        minLength: 1,\n        maxLength: 1\n      },\n      itemId: {\n        type: 'string',\n        /**\n         * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it\n         * because checkpoints use the itemId field for that.\n         */\n        maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4\n      },\n      checkpointData: {\n        type: 'object',\n        additionalProperties: true\n      },\n      docData: {\n        type: 'object',\n        properties: replicatedDocumentsSchema.properties\n      },\n      isResolvedConflict: {\n        type: 'string'\n      }\n    },\n    keyCompression: replicatedDocumentsSchema.keyCompression,\n    required: ['id', 'isCheckpoint', 'itemId']\n  };\n  if (encrypted) {\n    baseSchema.encrypted = ['docData'];\n  }\n  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);\n  return metaInstanceSchema;\n}\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState(state, docIds) {\n  return state.input.metaInstance.findDocumentsById(docIds.map(docId => {\n    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {\n      itemId: docId,\n      isCheckpoint: '0'\n    });\n    return useId;\n  }), true).then(metaDocs => {\n    var ret = {};\n    Object.values(metaDocs).forEach(metaDoc => {\n      ret[metaDoc.itemId] = {\n        docData: metaDoc.docData,\n        metaDocument: metaDoc\n      };\n    });\n    return ret;\n  });\n}\nexport async function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {\n  var docId = newMasterDocState[state.primaryPath];\n  var newMeta = previous ? flatCloneDocWithMeta(previous) : {\n    id: '',\n    isCheckpoint: '0',\n    itemId: docId,\n    docData: newMasterDocState,\n    _attachments: {},\n    _deleted: false,\n    _rev: getDefaultRevision(),\n    _meta: {\n      lwt: 0\n    }\n  };\n  newMeta.docData = newMasterDocState;\n\n  /**\n   * Sending isResolvedConflict with the value undefined\n   * will throw a schema validation error because it must be either\n   * not set or have a string.\n   */\n  if (isResolvedConflict) {\n    newMeta.isResolvedConflict = isResolvedConflict;\n  }\n  newMeta._meta.lwt = now();\n  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);\n  newMeta._rev = createRevision(await state.checkpointKey, previous);\n  var ret = {\n    previous,\n    document: newMeta\n  };\n  return ret;\n}\n", "import { firstValueFrom, filter, mergeMap } from 'rxjs';\nimport { newRxError } from \"../rx-error.js\";\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, createRevision, ensureNotFalsy, flatClone, getDefaultRevision, getHeightOfRevision, now, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'down');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'down', state.input.initialCheckpoint.downstream);\n    }\n  }\n  var identifierHash = await state.input.hashFunction(state.input.identifier);\n  var replicationHandler = state.input.replicationHandler;\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var openTasks = [];\n  function addNewTask(task) {\n    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n    var taskWithTime = {\n      time: timer++,\n      task\n    };\n    openTasks.push(taskWithTime);\n    state.streamQueue.down = state.streamQueue.down.then(() => {\n      var useTasks = [];\n      while (openTasks.length > 0) {\n        state.events.active.down.next(true);\n        var innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n        /**\n         * If the task came in before the last time we started the pull\n         * from the master, then we can drop the task.\n         */\n        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n          continue;\n        }\n        if (innerTaskWithTime.task === 'RESYNC') {\n          if (useTasks.length === 0) {\n            useTasks.push(innerTaskWithTime.task);\n            break;\n          } else {\n            break;\n          }\n        }\n        useTasks.push(innerTaskWithTime.task);\n      }\n      if (useTasks.length === 0) {\n        return;\n      }\n      if (useTasks[0] === 'RESYNC') {\n        return downstreamResyncOnce();\n      } else {\n        return downstreamProcessChanges(useTasks);\n      }\n    }).then(() => {\n      state.events.active.down.next(false);\n      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {\n        state.firstSyncDone.down.next(true);\n      }\n    });\n  }\n  addNewTask('RESYNC');\n\n  /**\n   * If a write on the master happens, we have to trigger the downstream.\n   * Only do this if not canceled yet, otherwise firstValueFrom errors\n   * when running on a completed observable.\n   */\n  if (!state.events.canceled.getValue()) {\n    var sub = replicationHandler.masterChangeStream$.pipe(mergeMap(async ev => {\n      /**\n       * While a push is running, we have to delay all incoming\n       * events from the server to not mix up the replication state.\n       */\n      await firstValueFrom(state.events.active.up.pipe(filter(s => !s)));\n      return ev;\n    })).subscribe(task => {\n      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n      addNewTask(task);\n    });\n    // unsubscribe when replication is canceled\n    firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => sub.unsubscribe());\n  }\n\n  /**\n   * For faster performance, we directly start each write\n   * and then await all writes at the end.\n   */\n  var lastTimeMasterChangesRequested = -1;\n  async function downstreamResyncOnce() {\n    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = [];\n    while (!state.events.canceled.getValue()) {\n      lastTimeMasterChangesRequested = timer++;\n      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);\n      if (downResult.documents.length === 0) {\n        break;\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));\n\n      /**\n       * By definition we stop pull when the pulled documents\n       * do not fill up the pullBatchSize because we\n       * can assume that the remote has no more documents.\n       */\n      if (downResult.documents.length < state.input.pullBatchSize) {\n        break;\n      }\n    }\n    await Promise.all(promises);\n  }\n  function downstreamProcessChanges(tasks) {\n    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n    var docsOfAllTasks = [];\n    var lastCheckpoint = null;\n    tasks.forEach(task => {\n      if (task === 'RESYNC') {\n        throw new Error('SNH');\n      }\n      appendToArray(docsOfAllTasks, task.documents);\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n    });\n    return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));\n  }\n\n  /**\n   * It can happen that the calls to masterChangesSince() or the changeStream()\n   * are way faster then how fast the documents can be persisted.\n   * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n   * and process them together if possible.\n   * This often bundles up single writes and improves performance\n   * by processing the documents in bulks.\n   */\n  var persistenceQueue = PROMISE_RESOLVE_VOID;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  function persistFromMaster(docs, checkpoint) {\n    var primaryPath = state.primaryPath;\n    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n\n    /**\n     * Run in the queue\n     * with all open documents from nonPersistedFromMaster.\n     */\n    persistenceQueue = persistenceQueue.then(() => {\n      var downDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(downDocsById);\n      if (state.events.canceled.getValue() || docIds.length === 0) {\n        return PROMISE_RESOLVE_VOID;\n      }\n      var writeRowsToFork = [];\n      var writeRowsToForkById = {};\n      var writeRowsToMeta = {};\n      var useMetaWriteRows = [];\n      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkStateList, assumedMasterState]) => {\n        var currentForkState = new Map();\n        currentForkStateList.forEach(doc => currentForkState.set(doc[primaryPath], doc));\n        return Promise.all(docIds.map(async docId => {\n          var forkStateFullDoc = currentForkState.get(docId);\n          var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false) : undefined;\n          var masterState = downDocsById[docId];\n          var assumedMaster = assumedMasterState[docId];\n          if (assumedMaster && forkStateFullDoc && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {\n            /**\n             * The current fork state represents a resolved conflict\n             * that first must be send to the master in the upstream.\n             * All conflicts are resolved by the upstream.\n             */\n            // return PROMISE_RESOLVE_VOID;\n            await state.streamQueue.up;\n          }\n          var isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ? false : state.input.conflictHandler.isEqual(assumedMaster.docData, forkStateDocData, 'downstream-check-if-equal-0');\n          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc && forkStateFullDoc._meta[state.input.identifier] && getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]) {\n            isAssumedMasterEqualToForkState = true;\n          }\n          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {\n            /**\n             * We have a non-upstream-replicated\n             * local write to the fork.\n             * This means we ignore the downstream of this document\n             * because anyway the upstream will first resolve the conflict.\n             */\n            return PROMISE_RESOLVE_VOID;\n          }\n          var areStatesExactlyEqual = !forkStateDocData ? false : state.input.conflictHandler.isEqual(masterState, forkStateDocData, 'downstream-check-if-equal-1');\n          if (forkStateDocData && areStatesExactlyEqual) {\n            /**\n             * Document states are exactly equal.\n             * This can happen when the replication is shut down\n             * unexpected like when the user goes offline.\n             *\n             * Only when the assumedMaster is different from the forkState,\n             * we have to patch the document in the meta instance.\n             */\n            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {\n              useMetaWriteRows.push(await getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : undefined));\n            }\n            return PROMISE_RESOLVE_VOID;\n          }\n\n          /**\n           * All other master states need to be written to the forkInstance\n           * and metaInstance.\n           */\n          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {\n            _meta: flatClone(forkStateFullDoc._meta),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\n            _rev: getDefaultRevision()\n          } : {\n            _meta: {\n              lwt: now()\n            },\n            _rev: getDefaultRevision(),\n            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\n          });\n          /**\n           * If the remote works with revisions,\n           * we store the height of the next fork-state revision\n           * inside of the documents meta data.\n           * By doing so we can filter it out in the upstream\n           * and detect the document as being equal to master or not.\n           * This is used for example in the CouchDB replication plugin.\n           */\n          if (masterState._rev) {\n            var nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\n            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n            if (state.input.keepMeta) {\n              newForkState._rev = masterState._rev;\n            }\n          }\n          if (state.input.keepMeta && masterState._meta) {\n            newForkState._meta = masterState._meta;\n          }\n          var forkWriteRow = {\n            previous: forkStateFullDoc,\n            document: newForkState\n          };\n          forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(identifierHash, forkWriteRow.previous);\n          writeRowsToFork.push(forkWriteRow);\n          writeRowsToForkById[docId] = forkWriteRow;\n          writeRowsToMeta[docId] = await getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : undefined);\n        }));\n      }).then(async () => {\n        if (writeRowsToFork.length > 0) {\n          return state.input.forkInstance.bulkWrite(writeRowsToFork, await state.downstreamBulkWriteFlag).then(forkWriteResult => {\n            var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRowsToFork, forkWriteResult);\n            success.forEach(doc => {\n              var docId = doc[primaryPath];\n              state.events.processed.down.next(writeRowsToForkById[docId]);\n              useMetaWriteRows.push(writeRowsToMeta[docId]);\n            });\n            var mustThrow;\n            forkWriteResult.error.forEach(error => {\n              /**\n               * We do not have to care about downstream conflict errors here\n               * because on conflict, it will be solved locally and result in another write.\n               */\n              if (error.status === 409) {\n                return;\n              }\n              // other non-conflict errors must be handled\n              var throwMe = newRxError('RC_PULL', {\n                writeError: error\n              });\n              state.events.error.next(throwMe);\n              mustThrow = throwMe;\n            });\n            if (mustThrow) {\n              throw mustThrow;\n            }\n          });\n        }\n      }).then(() => {\n        if (useMetaWriteRows.length > 0) {\n          return state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows), 'replication-down-write-meta').then(metaWriteResult => {\n            metaWriteResult.error.forEach(writeError => {\n              state.events.error.next(newRxError('RC_PULL', {\n                id: writeError.documentId,\n                writeError\n              }));\n            });\n          });\n        }\n      }).then(() => {\n        /**\n         * For better performance we do not await checkpoint writes,\n         * but to ensure order on parallel checkpoint writes,\n         * we have to use a queue.\n         */\n        setCheckpoint(state, 'down', useCheckpoint);\n      });\n    }).catch(unhandledError => state.events.error.next(unhandledError));\n    return persistenceQueue;\n  }\n}\n", "import { getDefaultRevision, createRevision, now, flatClone } from \"../plugins/utils/index.js\";\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError(state, input, forkState) {\n  var conflictHandler = state.input.conflictHandler;\n  var isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, 'replication-resolve-conflict');\n  if (isEqual) {\n    /**\n     * Documents are equal,\n     * so this is not a conflict -> do nothing.\n     */\n    return undefined;\n  } else {\n    var resolved = await conflictHandler.resolve(input, 'replication-resolve-conflict');\n    /**\n     * We have a resolved conflict,\n     * use the resolved document data.\n     */\n    var resolvedDoc = Object.assign({}, resolved, {\n      /**\n       * Because the resolved conflict is written to the fork,\n       * we have to keep/update the forks _meta data, not the masters.\n       */\n      _meta: flatClone(forkState._meta),\n      _rev: getDefaultRevision(),\n      _attachments: flatClone(forkState._attachments)\n    });\n    resolvedDoc._meta.lwt = now();\n    resolvedDoc._rev = createRevision(await state.checkpointKey, forkState);\n    return resolvedDoc;\n  }\n}\n", "import { newRxError } from \"../../rx-error.js\";\nimport { ensureNotFalsy } from \"../utils/index.js\";\nexport function ensureSchemaSupportsAttachments(doc) {\n  var schemaJson = doc.collection.schema.jsonSchema;\n  if (!schemaJson.attachments) {\n    throw newRxError('AT1', {\n      link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n    });\n  }\n}\nexport function assignMethodsToAttachment(attachment) {\n  Object.entries(attachment.doc.collection.attachments).forEach(([funName, fun]) => {\n    Object.defineProperty(attachment, funName, {\n      get: () => fun.bind(attachment)\n    });\n  });\n}\n\n/**\n * Fill up the missing attachment.data of the newDocument\n * so that the new document can be send to somewhere else\n * which could then receive all required attachments data\n * that it did not have before.\n */\nexport async function fillWriteDataForAttachmentsChange(primaryPath, storageInstance, newDocument, originalDocument) {\n  if (!newDocument._attachments || originalDocument && !originalDocument._attachments) {\n    throw new Error('_attachments missing');\n  }\n  var docId = newDocument[primaryPath];\n  var originalAttachmentsIds = new Set(originalDocument && originalDocument._attachments ? Object.keys(originalDocument._attachments) : []);\n  await Promise.all(Object.entries(newDocument._attachments).map(async ([key, value]) => {\n    if ((!originalAttachmentsIds.has(key) || originalDocument && ensureNotFalsy(originalDocument._attachments)[key].digest !== value.digest) && !value.data) {\n      var attachmentDataString = await storageInstance.getAttachmentData(docId, key, value.digest);\n      value.data = attachmentDataString;\n    }\n  }));\n  return newDocument;\n}\n", "import { map } from 'rxjs';\nimport { blobToBase64String, blobToString, createBlobFromBase64, flatClone, getBlobSize, PROMISE_RESOLVE_VOID } from \"../../plugins/utils/index.js\";\nimport { assignMethodsToAttachment, ensureSchemaSupportsAttachments } from \"./attachments-utils.js\";\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport var RxAttachment = /*#__PURE__*/function () {\n  function RxAttachment({\n    doc,\n    id,\n    type,\n    length,\n    digest\n  }) {\n    this.doc = doc;\n    this.id = id;\n    this.type = type;\n    this.length = length;\n    this.digest = digest;\n    assignMethodsToAttachment(this);\n  }\n  var _proto = RxAttachment.prototype;\n  _proto.remove = function remove() {\n    return this.doc.collection.incrementalWriteQueue.addWrite(this.doc._data, docWriteData => {\n      delete docWriteData._attachments[this.id];\n      return docWriteData;\n    }).then(() => {});\n  }\n\n  /**\n   * returns the data for the attachment\n   */;\n  _proto.getData = async function getData() {\n    var plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(this.doc.primary, this.id, this.digest);\n    var ret = await createBlobFromBase64(plainDataBase64, this.type);\n    return ret;\n  };\n  _proto.getStringData = async function getStringData() {\n    var data = await this.getData();\n    var asString = await blobToString(data);\n    return asString;\n  };\n  return RxAttachment;\n}();\nexport function fromStorageInstanceResult(id, attachmentData, rxDocument) {\n  return new RxAttachment({\n    doc: rxDocument,\n    id,\n    type: attachmentData.type,\n    length: attachmentData.length,\n    digest: attachmentData.digest\n  });\n}\nexport async function putAttachment(attachmentData) {\n  ensureSchemaSupportsAttachments(this);\n  var dataSize = getBlobSize(attachmentData.data);\n  var dataString = await blobToBase64String(attachmentData.data);\n  var digest = await this.collection.database.hashFunction(dataString);\n  var id = attachmentData.id;\n  var type = attachmentData.type;\n  var data = dataString;\n  return this.collection.incrementalWriteQueue.addWrite(this._data, docWriteData => {\n    docWriteData = flatClone(docWriteData);\n    docWriteData._attachments = flatClone(docWriteData._attachments);\n    docWriteData._attachments[id] = {\n      length: dataSize,\n      type,\n      data,\n      digest\n    };\n    return docWriteData;\n  }).then(writeResult => {\n    var newDocument = this.collection._docCache.getCachedRxDocument(writeResult);\n    var attachmentDataOfId = writeResult._attachments[id];\n    var attachment = fromStorageInstanceResult(id, attachmentDataOfId, newDocument);\n    return attachment;\n  });\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(id) {\n  ensureSchemaSupportsAttachments(this);\n  var docData = this._data;\n  if (!docData._attachments || !docData._attachments[id]) return null;\n  var attachmentData = docData._attachments[id];\n  var attachment = fromStorageInstanceResult(id, attachmentData, this);\n  return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments() {\n  ensureSchemaSupportsAttachments(this);\n  var docData = this._data;\n\n  // if there are no attachments, the field is missing\n  if (!docData._attachments) {\n    return [];\n  }\n  return Object.keys(docData._attachments).map(id => {\n    return fromStorageInstanceResult(id, docData._attachments[id], this);\n  });\n}\nexport async function preMigrateDocument(data) {\n  var attachments = data.docData._attachments;\n  if (attachments) {\n    var newAttachments = {};\n    await Promise.all(Object.keys(attachments).map(async attachmentId => {\n      var attachment = attachments[attachmentId];\n      var docPrimary = data.docData[data.oldCollection.schema.primaryPath];\n      var rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId, attachment.digest);\n      var digest = await data.oldCollection.database.hashFunction(rawAttachmentData);\n      newAttachments[attachmentId] = {\n        length: attachment.length,\n        type: attachment.type,\n        data: rawAttachmentData,\n        digest\n      };\n    }));\n\n    /**\n     * Hooks mutate the input\n     * instead of returning stuff\n     */\n    data.docData._attachments = newAttachments;\n  }\n}\nexport function postMigrateDocument(_action) {\n  /**\n   * No longer needed because\n   * we store the attachments data buffers directly in the document.\n   */\n  return PROMISE_RESOLVE_VOID;\n}\nexport var RxDBAttachmentsPlugin = {\n  name: 'attachments',\n  rxdb: true,\n  prototypes: {\n    RxDocument: proto => {\n      proto.putAttachment = putAttachment;\n      proto.getAttachment = getAttachment;\n      proto.allAttachments = allAttachments;\n      Object.defineProperty(proto, 'allAttachments$', {\n        get: function allAttachments$() {\n          return this.$.pipe(map(rxDocument => Object.entries(rxDocument.toJSON(true)._attachments)), map(entries => {\n            return entries.map(([id, attachmentData]) => {\n              return fromStorageInstanceResult(id, attachmentData, this);\n            });\n          }));\n        }\n      });\n    }\n  },\n  overwritable: {},\n  hooks: {\n    preMigrateDocument: {\n      after: preMigrateDocument\n    },\n    postMigrateDocument: {\n      after: postMigrateDocument\n    }\n  }\n};\nexport * from \"./attachments-utils.js\";\n", "import { firstValueFrom, filter } from 'rxjs';\nimport { getChangedDocumentsSince, getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from \"../rx-storage-helper.js\";\nimport { appendToArray, batchArray, clone, ensureNotFalsy, getHeightOfRevision, PROMISE_RESOLVE_FALSE } from \"../plugins/utils/index.js\";\nimport { getLastCheckpointDoc, setCheckpoint } from \"./checkpoint.js\";\nimport { resolveConflictError } from \"./conflicts.js\";\nimport { stripAttachmentsDataFromMetaWriteRows, writeDocToDocState } from \"./helper.js\";\nimport { getAssumedMasterState, getMetaWriteRow } from \"./meta-instance.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { newRxError } from \"../rx-error.js\";\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream(state) {\n  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {\n    var checkpointDoc = await getLastCheckpointDoc(state, 'up');\n    if (!checkpointDoc) {\n      await setCheckpoint(state, 'up', state.input.initialCheckpoint.upstream);\n    }\n  }\n  var replicationHandler = state.input.replicationHandler;\n  state.streamQueue.up = state.streamQueue.up.then(() => {\n    return upstreamInitialSync().then(() => {\n      return processTasks();\n    });\n  });\n\n  // used to detect which tasks etc can in it at which order.\n  var timer = 0;\n  var initialSyncStartTime = -1;\n  var openTasks = [];\n  var persistenceQueue = PROMISE_RESOLVE_FALSE;\n  var nonPersistedFromMaster = {\n    docs: {}\n  };\n  var sub = state.input.forkInstance.changeStream().subscribe(eventBulk => {\n    if (state.events.paused.getValue()) {\n      return;\n    }\n    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n    openTasks.push({\n      task: eventBulk,\n      time: timer++\n    });\n    if (!state.events.active.up.getValue()) {\n      state.events.active.up.next(true);\n    }\n    if (state.input.waitBeforePersist) {\n      return state.input.waitBeforePersist().then(() => processTasks());\n    } else {\n      return processTasks();\n    }\n  });\n  var subResync = replicationHandler.masterChangeStream$.pipe(filter(ev => ev === 'RESYNC')).subscribe(() => {\n    openTasks.push({\n      task: 'RESYNC',\n      time: timer++\n    });\n    processTasks();\n  });\n\n  // unsubscribe when replication is canceled\n  firstValueFrom(state.events.canceled.pipe(filter(canceled => !!canceled))).then(() => {\n    sub.unsubscribe();\n    subResync.unsubscribe();\n  });\n  async function upstreamInitialSync() {\n    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n    if (state.events.canceled.getValue()) {\n      return;\n    }\n    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n    var lastCheckpoint = await state.checkpointQueue;\n    var promises = new Set();\n    var _loop = async function () {\n      initialSyncStartTime = timer++;\n\n      /**\n       * Throttle the calls to\n       * forkInstance.getChangedDocumentsSince() so that\n       * if the pushing to the remote is slower compared to the\n       * pulling out of forkInstance, we do not block the UI too much\n       * and have a big memory spike with all forkInstance documents.\n       */\n      if (promises.size > 3) {\n        await Promise.race(Array.from(promises));\n      }\n      var upResult = await getChangedDocumentsSince(state.input.forkInstance, state.input.pushBatchSize, lastCheckpoint);\n      if (upResult.documents.length === 0) {\n        return 1; // break\n      }\n      lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n      var promise = persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint));\n      promises.add(promise);\n      promise.catch().then(() => promises.delete(promise));\n    };\n    while (!state.events.canceled.getValue()) {\n      if (await _loop()) break;\n    }\n\n    /**\n     * If we had conflicts during the initial sync,\n     * it means that we likely have new writes to the fork\n     * and so we have to run the initial sync again to upstream these new writes.\n     */\n    var resolvedPromises = await Promise.all(promises);\n    var hadConflicts = resolvedPromises.find(r => !!r);\n    if (hadConflicts) {\n      await upstreamInitialSync();\n    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {\n      state.firstSyncDone.up.next(true);\n    }\n  }\n\n  /**\n   * Takes all open tasks an processes them at once.\n   */\n  function processTasks() {\n    if (state.events.canceled.getValue() || openTasks.length === 0) {\n      state.events.active.up.next(false);\n      return;\n    }\n    state.stats.up.processTasks = state.stats.up.processTasks + 1;\n    state.events.active.up.next(true);\n    state.streamQueue.up = state.streamQueue.up.then(async () => {\n      /**\n       * Merge/filter all open tasks\n       */\n      var docs = [];\n      var checkpoint = {};\n      while (openTasks.length > 0) {\n        var taskWithTime = ensureNotFalsy(openTasks.shift());\n        /**\n         * If the task came in before the last time the initial sync fetching\n         * has run, we can ignore the task because the initial sync already processed\n         * these documents.\n         */\n        if (taskWithTime.time < initialSyncStartTime) {\n          continue;\n        }\n        if (taskWithTime.task === 'RESYNC') {\n          state.events.active.up.next(false);\n          await upstreamInitialSync();\n          return;\n        }\n\n        /**\n         * If the task came from the downstream, we can ignore these documents\n         * because we know they are replicated already.\n         * But even if they can be ignored, we later have to call persistToMaster()\n         * to have the correct checkpoint set.\n         */\n        if (taskWithTime.task.context !== (await state.downstreamBulkWriteFlag)) {\n          appendToArray(docs, taskWithTime.task.events.map(r => {\n            return r.documentData;\n          }));\n        }\n        checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n      }\n      await persistToMaster(docs, checkpoint);\n\n      // might have got more tasks while running persistToMaster()\n      if (openTasks.length === 0) {\n        state.events.active.up.next(false);\n      } else {\n        return processTasks();\n      }\n    });\n  }\n\n  /**\n   * Returns true if had conflicts,\n   * false if not.\n   */\n  function persistToMaster(docs, checkpoint) {\n    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n    /**\n     * Add the new docs to the non-persistent list\n     */\n    docs.forEach(docData => {\n      var docId = docData[state.primaryPath];\n      nonPersistedFromMaster.docs[docId] = docData;\n    });\n    nonPersistedFromMaster.checkpoint = checkpoint;\n    persistenceQueue = persistenceQueue.then(async () => {\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      var upDocsById = nonPersistedFromMaster.docs;\n      nonPersistedFromMaster.docs = {};\n      var useCheckpoint = nonPersistedFromMaster.checkpoint;\n      var docIds = Object.keys(upDocsById);\n      /**\n       * Even if we do not have anything to push,\n       * we still have to store the up-checkpoint.\n       * This ensures that when many documents have been pulled\n       * from the remote (that do not have to be pushed again),\n       * we continue at the correct position and do not have to load\n       * these documents from the storage again when the replication is restarted.\n       */\n      function rememberCheckpointBeforeReturn() {\n        return setCheckpoint(state, 'up', useCheckpoint);\n      }\n      ;\n      if (docIds.length === 0) {\n        rememberCheckpointBeforeReturn();\n        return false;\n      }\n      var assumedMasterState = await getAssumedMasterState(state, docIds);\n      var writeRowsToMaster = {};\n      var writeRowsToMasterIds = [];\n      var writeRowsToMeta = {};\n      var forkStateById = {};\n      await Promise.all(docIds.map(async docId => {\n        var fullDocData = upDocsById[docId];\n        forkStateById[docId] = fullDocData;\n        var docData = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n        var assumedMasterDoc = assumedMasterState[docId];\n\n        /**\n         * If the master state is equal to the\n         * fork state, we can assume that the document state is already\n         * replicated.\n         */\n        if (assumedMasterDoc &&\n        // if the isResolvedConflict is correct, we do not have to compare the documents.\n        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && state.input.conflictHandler.isEqual(assumedMasterDoc.docData, docData, 'upstream-check-if-equal') || (\n        /**\n         * If the master works with _rev fields,\n         * we use that to check if our current doc state\n         * is different from the assumedMasterDoc.\n         */\n\n        assumedMasterDoc && assumedMasterDoc.docData._rev && getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier])) {\n          return;\n        }\n        writeRowsToMasterIds.push(docId);\n        writeRowsToMaster[docId] = {\n          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n          newDocumentState: docData\n        };\n        writeRowsToMeta[docId] = await getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined);\n      }));\n      if (writeRowsToMasterIds.length === 0) {\n        rememberCheckpointBeforeReturn();\n        return false;\n      }\n      var writeRowsArray = Object.values(writeRowsToMaster);\n      var conflictIds = new Set();\n      var conflictsById = {};\n\n      /**\n       * To always respect the push.batchSize,\n       * we have to split the write rows into batches\n       * to ensure that replicationHandler.masterWrite() is never\n       * called with more documents than what the batchSize limits.\n       */\n      var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n      await Promise.all(writeBatches.map(async writeBatch => {\n        // enhance docs with attachments\n        if (state.hasAttachments) {\n          await Promise.all(writeBatch.map(async row => {\n            row.newDocumentState = await fillWriteDataForAttachmentsChange(state.primaryPath, state.input.forkInstance, clone(row.newDocumentState), row.assumedMasterState);\n          }));\n        }\n        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n        masterWriteResult.forEach(conflictDoc => {\n          var id = conflictDoc[state.primaryPath];\n          conflictIds.add(id);\n          conflictsById[id] = conflictDoc;\n        });\n      }));\n      var useWriteRowsToMeta = [];\n      writeRowsToMasterIds.forEach(docId => {\n        if (!conflictIds.has(docId)) {\n          state.events.processed.up.next(writeRowsToMaster[docId]);\n          useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n        }\n      });\n      if (state.events.canceled.getValue()) {\n        return false;\n      }\n      if (useWriteRowsToMeta.length > 0) {\n        await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta), 'replication-up-write-meta');\n        // TODO what happens when we have conflicts here?\n      }\n\n      /**\n       * Resolve conflicts by writing a new document\n       * state to the fork instance and the 'real' master state\n       * to the meta instance.\n       * Non-409 errors will be detected by resolveConflictError()\n       */\n      var hadConflictWrites = false;\n      if (conflictIds.size > 0) {\n        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n        var conflictWriteFork = [];\n        var conflictWriteMeta = {};\n        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {\n          var writeToMasterRow = writeRowsToMaster[docId];\n          var input = {\n            newDocumentState: writeToMasterRow.newDocumentState,\n            assumedMasterState: writeToMasterRow.assumedMasterState,\n            realMasterState\n          };\n          return resolveConflictError(state, input, forkStateById[docId]).then(async resolved => {\n            if (resolved) {\n              state.events.resolvedConflicts.next({\n                input,\n                output: resolved\n              });\n              conflictWriteFork.push({\n                previous: forkStateById[docId],\n                document: resolved\n              });\n              var assumedMasterDoc = assumedMasterState[docId];\n              conflictWriteMeta[docId] = await getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined, resolved._rev);\n            }\n          });\n        }));\n        if (conflictWriteFork.length > 0) {\n          hadConflictWrites = true;\n          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, 'replication-up-write-conflict');\n          var mustThrow;\n          forkWriteResult.error.forEach(error => {\n            /**\n             * Conflict-Errors in the forkWriteResult must not be handled\n             * because they have been caused by a write to the forkInstance\n             * in between which will anyway trigger a new upstream cycle\n             * that will then resolved the conflict again.\n             */\n            if (error.status === 409) {\n              return;\n            }\n            // other non-conflict errors must be handled\n            var throwMe = newRxError('RC_PUSH', {\n              writeError: error\n            });\n            state.events.error.next(throwMe);\n            mustThrow = throwMe;\n          });\n          if (mustThrow) {\n            throw mustThrow;\n          }\n          var useMetaWrites = [];\n          var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, conflictWriteFork, forkWriteResult);\n          success.forEach(docData => {\n            var docId = docData[state.primaryPath];\n            useMetaWrites.push(conflictWriteMeta[docId]);\n          });\n          if (useMetaWrites.length > 0) {\n            await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites), 'replication-up-write-conflict-meta');\n          }\n          // TODO what to do with conflicts while writing to the metaInstance?\n        }\n      }\n\n      /**\n       * For better performance we do not await checkpoint writes,\n       * but to ensure order on parallel checkpoint writes,\n       * we have to use a queue.\n       */\n      rememberCheckpointBeforeReturn();\n      return hadConflictWrites;\n    }).catch(unhandledError => {\n      state.events.error.next(unhandledError);\n      return false;\n    });\n    return persistenceQueue;\n  }\n}\n", "/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\nimport { BehaviorSubject, combineLatest, filter, firstValueFrom, mergeMap, Subject } from 'rxjs';\nimport { getPrimaryFieldOfPrimaryKey } from \"../rx-schema-helper.js\";\nimport { clone, ensureNotFalsy, flatClone, PROMISE_RESOLVE_VOID } from \"../plugins/utils/index.js\";\nimport { getCheckpointKey } from \"./checkpoint.js\";\nimport { startReplicationDownstream } from \"./downstream.js\";\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from \"./helper.js\";\nimport { startReplicationUpstream } from \"./upstream.js\";\nimport { fillWriteDataForAttachmentsChange } from \"../plugins/attachments/index.js\";\nimport { getChangedDocumentsSince } from \"../rx-storage-helper.js\";\nimport { newRxError } from \"../rx-error.js\";\nexport * from \"./checkpoint.js\";\nexport * from \"./downstream.js\";\nexport * from \"./upstream.js\";\nexport * from \"./meta-instance.js\";\nexport * from \"./conflicts.js\";\nexport * from \"./helper.js\";\nexport * from \"./default-conflict-handler.js\";\nexport function replicateRxStorageInstance(input) {\n  input = flatClone(input);\n  input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n  input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n  var checkpointKeyPromise = getCheckpointKey(input);\n  var state = {\n    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n    hasAttachments: !!input.forkInstance.schema.attachments,\n    input,\n    checkpointKey: checkpointKeyPromise,\n    downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n    events: {\n      canceled: new BehaviorSubject(false),\n      paused: new BehaviorSubject(false),\n      active: {\n        down: new BehaviorSubject(true),\n        up: new BehaviorSubject(true)\n      },\n      processed: {\n        down: new Subject(),\n        up: new Subject()\n      },\n      resolvedConflicts: new Subject(),\n      error: new Subject()\n    },\n    stats: {\n      down: {\n        addNewTask: 0,\n        downstreamProcessChanges: 0,\n        downstreamResyncOnce: 0,\n        masterChangeStreamEmit: 0,\n        persistFromMaster: 0\n      },\n      up: {\n        forkChangeStreamEmit: 0,\n        persistToMaster: 0,\n        persistToMasterConflictWrites: 0,\n        persistToMasterHadConflicts: 0,\n        processTasks: 0,\n        upstreamInitialSync: 0\n      }\n    },\n    firstSyncDone: {\n      down: new BehaviorSubject(false),\n      up: new BehaviorSubject(false)\n    },\n    streamQueue: {\n      down: PROMISE_RESOLVE_VOID,\n      up: PROMISE_RESOLVE_VOID\n    },\n    checkpointQueue: PROMISE_RESOLVE_VOID,\n    lastCheckpointDoc: {}\n  };\n  startReplicationDownstream(state);\n  startReplicationUpstream(state);\n  return state;\n}\nexport function awaitRxStorageReplicationFirstInSync(state) {\n  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter(v => !!v)), state.firstSyncDone.up.pipe(filter(v => !!v))])).then(() => {});\n}\nexport function awaitRxStorageReplicationInSync(replicationState) {\n  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);\n}\nexport async function awaitRxStorageReplicationIdle(state) {\n  await awaitRxStorageReplicationFirstInSync(state);\n  while (true) {\n    var {\n      down,\n      up\n    } = state.streamQueue;\n    await Promise.all([up, down]);\n    /**\n     * If the Promises have not been reassigned\n     * after awaiting them, we know that the replication\n     * is in idle state at this point in time.\n     */\n    if (down === state.streamQueue.down && up === state.streamQueue.up) {\n      return;\n    }\n  }\n}\nexport function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken,\n/**\n * If set to true,\n * the _meta.lwt from the pushed documents is kept.\n * (Used in the migration to ensure checkpoints are still valid)\n */\nkeepMeta = false) {\n  instance = getUnderlyingPersistentStorage(instance);\n  var hasAttachments = !!instance.schema.attachments;\n  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n  var replicationHandler = {\n    masterChangeStream$: instance.changeStream().pipe(mergeMap(async eventBulk => {\n      var ret = {\n        checkpoint: eventBulk.checkpoint,\n        documents: await Promise.all(eventBulk.events.map(async event => {\n          var docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n          if (hasAttachments) {\n            docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n            /**\n             * Notice that the master never knows\n             * the client state of the document.\n             * Therefore we always send all attachments data.\n             */\n            undefined);\n          }\n          return docData;\n        }))\n      };\n      return ret;\n    })),\n    masterChangesSince(checkpoint, batchSize) {\n      return getChangedDocumentsSince(instance, batchSize, checkpoint).then(async result => {\n        return {\n          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n          documents: await Promise.all(result.documents.map(async plainDocumentData => {\n            var docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n            if (hasAttachments) {\n              docData = await fillWriteDataForAttachmentsChange(primaryPath, instance, clone(docData),\n              /**\n               * Notice the the master never knows\n               * the client state of the document.\n               * Therefore we always send all attachments data.\n               */\n              undefined);\n            }\n            return docData;\n          }))\n        };\n      });\n    },\n    async masterWrite(rows) {\n      var rowById = {};\n      rows.forEach(row => {\n        var docId = row.newDocumentState[primaryPath];\n        rowById[docId] = row;\n      });\n      var ids = Object.keys(rowById);\n      var masterDocsStateList = await instance.findDocumentsById(ids, true);\n      var masterDocsState = new Map();\n      masterDocsStateList.forEach(doc => masterDocsState.set(doc[primaryPath], doc));\n      var conflicts = [];\n      var writeRows = [];\n      await Promise.all(Object.entries(rowById).map(([id, row]) => {\n        var masterState = masterDocsState.get(id);\n        if (!masterState) {\n          writeRows.push({\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n          });\n        } else if (masterState && !row.assumedMasterState) {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        } else if (conflictHandler.isEqual(writeDocToDocState(masterState, hasAttachments, keepMeta), ensureNotFalsy(row.assumedMasterState), 'rxStorageInstanceToReplicationHandler-masterWrite') === true) {\n          writeRows.push({\n            previous: masterState,\n            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n          });\n        } else {\n          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n        }\n      }));\n      if (writeRows.length > 0) {\n        var result = await instance.bulkWrite(writeRows, 'replication-master-write');\n        result.error.forEach(err => {\n          if (err.status !== 409) {\n            throw newRxError('SNH', {\n              name: 'non conflict error',\n              error: err\n            });\n          } else {\n            conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta));\n          }\n        });\n      }\n      return conflicts;\n    }\n  };\n  return replicationHandler;\n}\nexport async function cancelRxStorageReplication(replicationState) {\n  replicationState.events.canceled.next(true);\n  replicationState.events.active.up.complete();\n  replicationState.events.active.down.complete();\n  replicationState.events.processed.up.complete();\n  replicationState.events.processed.down.complete();\n  replicationState.events.resolvedConflicts.complete();\n  replicationState.events.canceled.complete();\n  await replicationState.checkpointQueue;\n}\n", "/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport { getSchemaByObjectPath } from \"./rx-schema-helper.js\";\nimport { ensureNotFalsy, objectPathMonad } from \"./plugins/utils/index.js\";\nimport { INDEX_MAX, INDEX_MIN } from \"./query-planner.js\";\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\n\nexport function getIndexMeta(schema, index) {\n  var fieldNameProperties = index.map(fieldName => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    if (!schemaPart) {\n      throw new Error('not in schema: ' + fieldName);\n    }\n    var type = schemaPart.type;\n    var parsedLengths;\n    if (type === 'number' || type === 'integer') {\n      parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n    }\n    var getValue = objectPathMonad(fieldName);\n    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n    var getIndexStringPart;\n    if (type === 'string') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        if (!fieldValue) {\n          fieldValue = '';\n        }\n        return fieldValue.padEnd(maxLength, ' ');\n      };\n    } else if (type === 'boolean') {\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return fieldValue ? '1' : '0';\n      };\n    } else {\n      // number\n      getIndexStringPart = docData => {\n        var fieldValue = getValue(docData);\n        return getNumberIndexString(parsedLengths, fieldValue);\n      };\n    }\n    var ret = {\n      fieldName,\n      schemaPart,\n      parsedLengths,\n      getValue,\n      getIndexStringPart\n    };\n    return ret;\n  });\n  return fieldNameProperties;\n}\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var fieldNamePropertiesAmount = fieldNameProperties.length;\n  var indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n  /**\n   * @hotPath Performance of this function is very critical!\n   */\n  var ret = function (docData) {\n    var str = '';\n    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {\n      str += indexPartsFunctions[i](docData);\n    }\n    return str;\n  };\n  return ret;\n}\nexport function getStringLengthOfIndexNumber(schemaPart) {\n  var minimum = Math.floor(schemaPart.minimum);\n  var maximum = Math.ceil(schemaPart.maximum);\n  var multipleOf = schemaPart.multipleOf;\n  var valueSpan = maximum - minimum;\n  var nonDecimals = valueSpan.toString().length;\n  var multipleOfParts = multipleOf.toString().split('.');\n  var decimals = 0;\n  if (multipleOfParts.length > 1) {\n    decimals = multipleOfParts[1].length;\n  }\n  return {\n    minimum,\n    maximum,\n    nonDecimals,\n    decimals,\n    roundedMinimum: minimum\n  };\n}\nexport function getIndexStringLength(schema, index) {\n  var fieldNameProperties = getIndexMeta(schema, index);\n  var length = 0;\n  fieldNameProperties.forEach(props => {\n    var schemaPart = props.schemaPart;\n    var type = schemaPart.type;\n    if (type === 'string') {\n      length += schemaPart.maxLength;\n    } else if (type === 'boolean') {\n      length += 1;\n    } else {\n      var parsedLengths = props.parsedLengths;\n      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n    }\n  });\n  return length;\n}\nexport function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {\n  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n  // we can safely trim here because the primary key is not allowed to start or end with a space char.\n  var primaryKey = paddedPrimaryKey.trim();\n  return primaryKey;\n}\nexport function getNumberIndexString(parsedLengths, fieldValue) {\n  /**\n   * Ensure that the given value is in the boundaries\n   * of the schema, otherwise it would create a broken index string.\n   * This can happen for example if you have a minimum of 0\n   * and run a query like\n   * selector {\n   *  numField: { $gt: -1000 }\n   * }\n   */\n  if (typeof fieldValue === 'undefined') {\n    fieldValue = 0;\n  }\n  if (fieldValue < parsedLengths.minimum) {\n    fieldValue = parsedLengths.minimum;\n  }\n  if (fieldValue > parsedLengths.maximum) {\n    fieldValue = parsedLengths.maximum;\n  }\n  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n  if (parsedLengths.decimals > 0) {\n    var splitByDecimalPoint = fieldValue.toString().split('.');\n    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n    str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n  }\n  return str;\n}\nexport function getStartIndexStringFromLowerBound(schema, index, lowerBound) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = lowerBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n        if (typeof bound === 'string') {\n          str += bound.padEnd(maxLength, ' ');\n        } else {\n          // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n          str += ''.padEnd(maxLength, ' ');\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += '0';\n        } else if (bound === INDEX_MIN) {\n          str += '0';\n        } else if (bound === INDEX_MAX) {\n          str += '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MIN) {\n          var fillChar = '0';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else if (bound === INDEX_MAX) {\n          str += getNumberIndexString(parsedLengths, parsedLengths.maximum);\n        } else {\n          var add = getNumberIndexString(parsedLengths, bound);\n          str += add;\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\nexport function getStartIndexStringFromUpperBound(schema, index, upperBound) {\n  var str = '';\n  index.forEach((fieldName, idx) => {\n    var schemaPart = getSchemaByObjectPath(schema, fieldName);\n    var bound = upperBound[idx];\n    var type = schemaPart.type;\n    switch (type) {\n      case 'string':\n        var maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n        if (typeof bound === 'string' && bound !== INDEX_MAX) {\n          str += bound.padEnd(maxLength, ' ');\n        } else if (bound === INDEX_MIN) {\n          str += ''.padEnd(maxLength, ' ');\n        } else {\n          str += ''.padEnd(maxLength, INDEX_MAX);\n        }\n        break;\n      case 'boolean':\n        if (bound === null) {\n          str += '1';\n        } else {\n          var boolToStr = bound ? '1' : '0';\n          str += boolToStr;\n        }\n        break;\n      case 'number':\n      case 'integer':\n        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);\n        if (bound === null || bound === INDEX_MAX) {\n          var fillChar = '9';\n          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else if (bound === INDEX_MIN) {\n          var _fillChar = '0';\n          str += _fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n        } else {\n          str += getNumberIndexString(parsedLengths, bound);\n        }\n        break;\n      default:\n        throw new Error('unknown index type ' + type);\n    }\n  });\n  return str;\n}\n\n/**\n * Used in storages where it is not possible\n * to define inclusiveEnd/inclusiveStart\n */\nexport function changeIndexableStringByOneQuantum(str, direction) {\n  var lastChar = str.slice(-1);\n  var charCode = lastChar.charCodeAt(0);\n  charCode = charCode + direction;\n  var withoutLastChar = str.slice(0, -1);\n  return withoutLastChar + String.fromCharCode(charCode);\n}\n"],
  "mappings": "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",
  "names": ["RxSchema", "getDocumentPrototype", "IncrementalWriteQueue", "item", "lastChar", "getProperty", "getProperty", "simpleBdd", "eventReduceEvent", "QueryCache", "rxQuery", "DocumentCache", "RxQuerySingleResult", "map", "RxQueryBase", "docs", "doesMatchNow", "docId", "docData", "ChangeEventBuffer", "RxCollectionBase", "docData", "useDocData", "IdleQueue", "requestIdlePromise", "resolveFromOutside", "RxDatabaseBase", "requestIdlePromise", "RxAttachment", "lastChar"]
}
